<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Z5omes | A Zome Maker</title>
    <meta name="description"
          content="Z5omes allows you to create 3D models for free. You can now create your models in GoodKarma and Semicone (Axis of symmetry) and export them in STL (sketchup import: mm unit, inverted YZ), OBJ or other formats.">

    <!-- Mobile Capability -->
    <meta name="application-name" content="Z5omes"/>
    <link rel="manifest" href="manifest.json?v=1.0.16b05"/>
    <meta name="apple-mobile-web-app-title" content="Z5omes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/>

    <!-- Favicons -->
    <link rel="apple-touch-icon" sizes="180x180" href="img/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="img/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="img/icons/favicon-16x16.png">
    <link rel="mask-icon" href="img/icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="theme-color" content="#ffffff">

    <!-- Stylesheets -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/fa.min.css" rel="stylesheet">
    <link href="css/flag-icons.css" rel="stylesheet">
    <link href="css/custom.css?v=1.0.16b05" rel="stylesheet">

    <!-- Highlight.js CSS -->
    <link href="js/highlight/styles/atom-one-dark-reasonable.min.css" rel="stylesheet">
</head>

<body class="bg-light">

<div x-data="settings" @zome-renderer-is-ready.window="__make_zome">
    <div class="loading-bar" x-show="is_computing" style="z-index: 9999;">
        <div></div>
    </div>
    <div x-show="show_splash_screen"
         class="bg-white position-fixed top-0 start-0"
         style="height:100%;width:100%;z-index: 9998;">
        <div class=" d-flex align-items-center" style="height:100%;width:100%;">
            <div class="d-flex align-items-center text-decoration-none m-auto position-relative d-flex">
                <img src="img/logo_zome.svg" width="80" title="Z5omes" class="me-2" alt="Z5omes">
                <h1 class="text-primary mb-0 ">
                    Z<span class="fs-4">o</span>oOo<span class="fs-4">o</span>mes
                </h1>
            </div>
        </div>
    </div>

    <div class="offcanvas offcanvas-end" tabindex="-1" data-bs-scroll="true" data-bs-backdrop="false"
         id="offcanvasSettings" aria-labelledby="settingsLabel">

        <div class="offcanvas-body">
            <div class="d-flex align-items-center mt-2 mb-3">
                <!-- Reset Params Button -->
                <button @click="reset_params" class="btn btn-primary btn-sm p-2 me-2"
                        data-bs-toggle="tooltip" :title="i18n('tooltip_reset_settings')">
                    <i class="fa-solid fa-rotate"></i>
                </button>

                <!-- Save Params Button -->
                <button @click="save_params" class="btn btn-primary btn-sm p-2 me-2"
                        data-bs-toggle="tooltip" :title="i18n('tooltip_save_settings')">
                    <i class="fa-solid fa-floppy-disk"></i>
                </button>

                <!-- Copy Link -->
                <button id="copy-url-btn" class="btn btn-primary btn-sm p-2 me-auto"
                        data-bs-toggle="tooltip" :title="i18n('tooltip_copy_link')">
                    <i class="fa-solid fa-link"></i>
                </button>

                <!-- Language Dropdown -->
                <div class="dropdown">
                    <button class="btn btn-primary btn-sm dropdown-toggle"
                            type="button" data-bs-toggle="dropdown" aria-expanded="false">
                        <span class="fi fa-fw" :class="`fi-${params.language}`"></span>
                    </button>
                    <ul class="dropdown-menu">
                        <template x-for="(obj, lng) in I18N_LANGUAGES" :key="lng">
                            <li>
                                <button class="dropdown-item" @click="params.language = lng">
                                    <span class="fi" :class="`fi-${lng}`"></span>
                                    <span x-text="obj.name"></span>
                                </button>
                            </li>
                        </template>
                    </ul>
                </div>

                <!-- Show Help -->
                <button class="btn btn-sm p-1"
                        @click="params.help_is_displayed = !params.help_is_displayed"
                        :class="params.help_is_displayed ? 'text-primary' : 'text-secondary'"
                        data-bs-toggle="tooltip" :title="i18n('tooltip_display_help')">
                    <i class="fa-solid fa-question-circle fa-fw"></i>
                </button>

                <!-- Close Button -->
                <button type="button" class="btn btn-sm p-1"
                        data-bs-dismiss="offcanvas"
                        data-bs-toggle="tooltip" :title="i18n('tooltip_close')">
                    <i class="fa-solid fa-close fa-fw"></i>
                </button>
            </div>

            <div class="d-flex align-items-center mb-3">
                <h5 class="text-secondary my-1 me-3">
                    <i class="fa-solid fa-rhombus me-1"></i>
                    <span x-text="i18n('shape')" class="up-first"></span>
                </h5>

                <!-- Randomize Button -->
                <button @click="randomize_shape" class="btn btn-primary btn-sm p-2 me-auto"
                        data-bs-toggle="tooltip" :title="i18n('tooltip_randomize_shape')">
                    <i class="fa-solid fa-dice"></i>
                </button>
            </div>

            <div class="text-muted small aligned-form">
                <div x-show="params.help_is_displayed">
                    <p class="mb-1" x-text="i18n('help_shape')"></p>

                    <!-- Num of Spirals -->
                    <b>N</b> :
                    <span x-text="i18n('help_n_param')"></span>
                </div>
                <div class="input-group input-group-sm mb-3">
                    <span class="input-group-text"
                          data-bs-toggle="tooltip" :title="i18n('help_n_param')">
                        N
                    </span>
                    <input class="form-control form-range" :max="26" min="3" step="1" type="range"
                           x-model.number="params.num_spirals" x-ref="num_spirals_slider">
                    <input class="form-control" step="1" type="number"
                           x-model.lazy.number="params.num_spirals">
                </div>

                <!-- Num of rhombuses vertically (from the top) -->
                <div x-show="!params.use_hr_mode">
                    <div x-show="params.help_is_displayed">
                        <b>M</b> :
                        <span x-text="i18n('help_m_param')"></span>
                    </div>
                    <div class="input-group input-group-sm mb-3">
                        <button class="btn btn-primary text-start" type="button"
                                data-bs-toggle="tooltip" :title="i18n('help_m_param')"
                                @click="params.use_hr_mode = !params.use_hr_mode">
                            M
                        </button>
                        <input class="form-control form-range" min="1" :max="params.num_spirals - 1" step="1"
                               type="range"
                               x-model.number="num_rhombuses_vertically" x-ref="num_rhombuses_vertically_slider">
                        <input class="form-control" step="1" type="number"
                               x-model.lazy.number="num_rhombuses_vertically">
                    </div>
                </div>

                <!-- Height Ratio of Zome -->
                <div x-show="params.use_hr_mode">
                    <div x-show="params.help_is_displayed">
                        <b>HR</b> :
                        <span x-text="i18n('help_hr_param')"></span>
                    </div>
                    <div class="input-group input-group-sm mb-3">
                        <button class="btn btn-primary text-start" type="button"
                                data-bs-toggle="tooltip" :title="i18n('help_hr_param')"
                                @click="params.use_hr_mode = !params.use_hr_mode">
                            HR
                        </button>
                        <input class="form-control form-range" max="1" min="0" step="0.0000001" type="range"
                               :min="to_decimal(2 / params.num_spirals)"
                               x-model.number="params.height_ratio" x-ref="height_ratio_slider">
                        <input class="form-control" step="0.01" type="number"
                               x-model.lazy.number="params.height_ratio">
                        <button class="btn btn-primary"
                                data-bs-toggle="tooltip" :title="i18n('help_magnetize_param')"
                                type="button"
                                :class="(params.height_ratio == suggested_height_ratio) ? 'btn-secondary' : ''"
                                @click="magnetize">
                            <i class="fa-solid fa-magnet fa-fw"></i>
                        </button>
                    </div>
                </div>

                <!-- Kite Ratio of Zome -->
                <div x-show="params.use_hr_mode">
                    <div x-show="params.help_is_displayed">
                        <b>KR</b> :
                        <span x-text="i18n('help_kr_param')"></span>
                    </div>
                    <div class="input-group input-group-sm mb-3">
                        <span class="input-group-text"
                              data-bs-toggle="tooltip" :title="i18n('help_kr_param')">
                            KR
                        </span>
                        <input class="form-control form-range" min="0.5" max="1.5" step="0.01" type="range"
                               @dblclick="params.kite_ratio = 1"
                               x-model.number="params.kite_ratio" x-ref="kite_ratio_slider">
                        <input class="form-control" step="0.01" type="number"
                               x-model.lazy.number="params.kite_ratio">
                        <button class="btn btn-primary" type="button"
                                data-bs-toggle="tooltip" :title="i18n('help_set_rhombus_param')"
                                :class="(is_rhombus) ? 'btn-secondary' : ''"
                                @click="is_rhombus = true">
                            <i class="fa-solid fa-rhombus fa-fw"></i>
                        </button>
                    </div>
                </div>

                <!--  Shape angle of Zome -->
                <div x-show="params.help_is_displayed">
                    <b>Θ | F</b> :
                    <span x-text="i18n('help_f_param')"></span>
                    <br>
                </div>
                <div class="input-group input-group-sm mb-3">
                    <button class="btn btn-primary text-start" type="button"
                            data-bs-toggle="tooltip" :title="i18n('help_f_param')"
                            @click="params.angle_unit = (params.angle_unit == 'tan') ? 'deg': 'tan'"
                            x-text="(params.angle_unit == 'tan') ? 'F' : 'Θ'">
                    </button>
                    <input class="form-control form-range" min="20" max="80" step="0.01" type="range"
                           x-model.number="params.theta_deg" x-ref="theta_deg_slider">
                    <input class="form-control" type="number" step="0.01" x-model.lazy.number="theta">
                    <select class="form-select unit-select" aria-label="Angle unit"
                            x-show="params.angle_unit != 'tan'" x-model="params.angle_unit">
                        <option selected value="deg">deg</option>
                        <option value="rad">rad</option>
                        <option hidden value="tan">tan</option>
                    </select>
                </div>
            </div>

            <hr>

            <div class="d-flex align-items-center mb-3">
                <h5 class="text-secondary my-1 me-auto">
                    <i class="fa-solid fa-frame rotate-45 me-1"></i>
                    <span x-text="i18n('framework')" class="up-first"></span>
                </h5>

                <select class="form-select form-select-sm unit-select"
                        aria-label="Measuring unit" x-model="params.measuring_unit">
                    <option value="mm">mm</option>
                    <option selected value="cm">cm</option>
                    <option value="m">m</option>
                </select>
            </div>

            <div class="text-muted small aligned-form">
                <!-- Zome Height before generating the timbers -->
                <div x-show="params.help_is_displayed">
                    <b>ZH</b> :
                    <span x-text="i18n('help_zh_param')"></span>
                </div>
                <div class="input-group input-group-sm mb-3">
                    <span class="input-group-text"
                          data-bs-toggle="tooltip" :title="i18n('help_zh_param')">
                    ZH
                    </span>
                    <input class="form-control form-range" min="100" max="10000" step="10" type="range"
                           x-model.number="params.zome_height_in_mm"
                           x-ref="zome_height_in_mm_slider">
                    <input class="form-control" step="1" type="number"
                           x-model.lazy.number="zome_height">
                </div>

                <!-- Timber width -->
                <div x-show="params.help_is_displayed">
                    <b>TW</b> :
                    <span x-text="i18n('help_tw_param')"></span>
                </div>
                <div class="input-group input-group-sm mb-3">
                    <span class="input-group-text"
                          data-bs-toggle="tooltip" :title="i18n('help_tw_param')">
                          TW
                    </span>
                    <input class="form-control form-range" min="1" :max="max_timber_width" step="1" type="range"
                           x-model.number="params.timber_width_in_mm" x-ref="timber_width_in_mm_slider">
                    <input class="form-control" step="1" type="number"
                           x-model.lazy.number="timber_width">
                </div>

                <!-- Timber thickness -->
                <div x-show="params.help_is_displayed">
                    <b>TT</b> :
                    <span x-text="i18n('help_tt_param')"></span>
                </div>
                <div class="input-group input-group-sm mb-3">
                    <span class="input-group-text"
                          data-bs-toggle="tooltip" :title="i18n('help_tt_param')">
                        TT
                    </span>
                    <input class="form-control form-range" min="1" :max="max_timber_thickness" step="1"
                           type="range"
                           x-model.number="params.timber_thickness_in_mm" x-ref="timber_thickness_in_mm_slider">
                    <input class="form-control" step="1" type="number"
                           x-model.lazy.number="timber_thickness">
                </div>

                <!-- Assembly method -->
                <div x-show="params.help_is_displayed">
                    <b>AM</b> :
                    <span x-text="i18n('help_am_param')"></span>
                    <ul>
                        <li x-text="i18n('help_am_param_1')"></li>
                        <li x-text="i18n('help_am_param_2')"></li>
                        <li x-text="i18n('help_am_param_3')"></li>
                    </ul>
                </div>
                <div class="input-group input-group-sm mb-3">
                <span class="input-group-text"
                      data-bs-toggle="tooltip" :title="i18n('help_am_param_2')">
                    AM
                </span>
                    <button class="btn btn-primary" type="button"
                            :class="(params.assembly_method == 2)? `disabled`: ``"
                            data-bs-toggle="tooltip" :title="i18n('help_am_param_1')"

                            @click="params.xpansion_direction = -params.xpansion_direction">
                        <i class="fa-solid fa-fw"
                           :class="(params.xpansion_direction < 0 || params.assembly_method == 2)? `fa-arrow-up-from-line` : `fa-arrow-down-from-line`"></i>
                    </button>
                    <select class="form-select" aria-label="Assembly method"
                            x-model.number="params.assembly_method">
                        <option selected value=0>GoodKarma</option>
                        <option value=1>Beveled</option>
                        <option value=2>Xpansion</option>
                    </select>
                    <button class="btn btn-primary" type="button"
                            data-bs-toggle="tooltip"
                            :title="i18n('help_am_param_3')"
                            @click="constrained_assembly_direction = constrained_assembly_direction + 1">
                        <i class="fa-solid fa-fw"
                           :class="ASSEMBLY_DIRECTION_ICONS[params.assembly_direction]"
                        ></i>
                    </button>
                </div>

                <!-- Vanishing point -->
                <div x-show="params.assembly_method < 2">
                    <div x-show="params.help_is_displayed">
                        <b>VP</b> :
                        <span x-text="i18n('help_vp_param')"></span>
                    </div>
                    <div class="input-group input-group-sm mb-3">
                        <span class="input-group-text"
                              data-bs-toggle="tooltip" :title="i18n('help_vp_param')">
                            VP
                        </span>
                        <input class="form-control form-range" :min="min_z_vanishing_point" :max="max_z_vanishing_point"
                               step="1" type="range" x-model.number="params.z_vanishing_point_in_mm"
                               @dblclick="is_vanishing_centered = true"
                               x-ref="z_vanishing_point_in_mm_slider">
                        <input class="form-control" step="1" type="number"
                               x-model.lazy.number="z_vanishing_point">
                        <button class="btn btn-primary" type="button"
                                data-bs-toggle="tooltip" :title="i18n('help_zc_param')"
                                :class="(is_vanishing_centered) ? 'btn-secondary' : ''"
                                @click="is_vanishing_centered = true">
                            <i class="fa-solid fa-arrows-to-circle fa-fw"></i>
                        </button>
                    </div>
                </div>

                <!-- Add footing -->
                <div x-show="params.help_is_displayed">
                    <b>FF</b> :
                    <span x-text="i18n('help_ft_param')"></span>
                </div>
                <div class="input-group input-group-sm mb-3">
                    <span class="input-group-text"
                          data-bs-toggle="tooltip" :title="i18n('help_ft_param')">
                        FT
                    </span>
                    <select class="form-select" aria-label="Footing"
                            x-model.number="params.add_footing">
                        <option selected value=0 x-text="i18n('opt_none')"></option>
                        <option value=1 x-text="i18n('opt_footing')"></option>
                    </select>
                </div>
            </div>
            <hr>

            <div class="d-flex align-items-center mb-3">
                <h5 class="text-secondary my-1 me-auto">
                    <i class="fa-solid fa-people-roof me-1"></i>
                    <span x-text="i18n('roof')" class="up-first"></span>
                </h5>
            </div>

            <div class="text-muted small aligned-form">
                <!-- Roof overflow -->
                <div x-show="params.help_is_displayed">
                    <b>RO</b> :
                    <span x-text="i18n('help_ro_param')"></span>
                </div>
                <div class="input-group input-group-sm mb-3">
                    <span class="input-group-text"
                          data-bs-toggle="tooltip" :title="i18n('help_ro_param')">
                    RO
                    </span>
                    <input class="form-control form-range" min="0" max="1000" step="1" type="range"
                           @dblclick="params.roof_overflow_in_mm = 0"
                           x-model.number="params.roof_overflow_in_mm" x-ref="roof_overflow_in_mm_slider">
                    <input class="form-control" step="1" type="number"
                           x-model.lazy.number="roof_overflow">
                </div>
            </div>
        </div>
    </div>

    <div class="auto-shift position-relative">
        <div class="container-xxl row m-auto">
            <div class="col mb-3 mt-3 px-1">
                <div class="d-flex align-items-center">
                    <a href="https://florianwns.github.io/z5omes/"
                       class="text-decoration-none me-auto d-flex align-items-center position-relative">
                        <img src="img/logo_zome.svg" width="46" title="Z5omes" class="me-2">
                        <h2 id="#title" class="text-primary mb-0 ">
                            <span class="d-none d-md-inline-block">
                                Z<span class="fs-4">o</span>oOo<span class="fs-4">o</span>mes
                            </span>
                            <span class="d-none d-sm-inline-block d-md-none">Z5omes</span>
                        </h2>
                        <span class="d-none d-sm-inline-block text-muted position-absolute end-0"
                              style="font-size: 10px; top:0px">v1.0.16b05</span>
                    </a>

                    <a href="https://www.paypal.com/paypalme/z5omes"
                       class="text-primary btn btn-sm fs-4 p-2"
                       data-bs-toggle="tooltip" :title="i18n('tooltip_link_buymeacoffee')">
                        <i class="fa-solid fa-coffee"></i>
                    </a>

                    <a href="https://m.me/ch/AbbRFxmdmE3kybZR/"
                       class="text-primary btn btn-sm fs-4 p-2"
                       data-bs-toggle="tooltip" :title="i18n('tooltip_link_facebook')">
                        <i class="fa-brands fa-facebook"></i>
                    </a>

                    <a href="https://www.youtube.com/@Z5omes"
                       class="text-primary btn btn-sm fs-4 p-2"
                       data-bs-toggle="tooltip" :title="i18n('tooltip_link_youtube')">
                        <i class="fa-brands fa-youtube"></i>
                    </a>

                    <a href="https://github.com/florianwns/z5omes"
                       class="text-primary btn btn-sm fs-4 p-2"
                       data-bs-toggle="tooltip" :title="i18n('tooltip_link_github')">
                        <i class="fa-brands fa-github"></i>
                    </a>
                    <a href="https://www.linkedin.com/in/florian-rey-346857185/"
                       class="text-primary btn btn-sm fs-4 p-2 me-4"
                       data-bs-toggle="tooltip" :title="i18n('tooltip_link_linkedin')">
                        <i class="fa-brands fa-linkedin"></i>
                    </a>

                    <button class="btn btn-primary btn-sm p-2 px-3" type="button"
                            data-bs-toggle="offcanvas"
                            data-bs-target="#offcanvasSettings" aria-controls="offcanvasSettings">
                        <i class="fa-solid fa-sliders"></i>
                    </button>
                </div>

                <div class="d-flex flex-column">
                    <nav class="navbar mx-auto mt-2">
                        <ul class="nav nav-pills" id="nav-tab" role="tablist">
                            <li class="nav-item">
                                <button class="nav-link active" id="nav-3D-tab" data-bs-toggle="tab"
                                        data-bs-target="#nav-3D"
                                        type="button" role="tab" aria-controls="nav-3D" aria-selected="true">
                                    <i class="fa-solid fa-chart-pyramid me-1"></i>
                                    <span x-text="i18n('view_3D')" class="up-first"></span>
                                </button>
                            </li>
                            <li>
                                <button class="nav-link" id="nav-print-tab" data-bs-toggle="tab"
                                        data-bs-target="#nav-print"
                                        type="button" role="tab" aria-controls="nav-print" aria-selected="false">
                                    <i class="fa-solid fa-print me-1"></i>
                                    <span x-text="i18n('origami')" class="up-first"></span>
                                </button>
                            </li>
                        </ul>
                    </nav>
                    <div class="tab-content h-100 mt-3">
                        <div class="tab-pane show active" id="nav-3D" role="tabpanel" aria-labelledby="nav-3D-tab"
                             tabindex="0" x-data="renderer_3D" @resize.window="__auto_size"
                             @zome-is-made.window="__process">

                            <p x-show="!framework_is_machinable" class="text-center mb-2">
                                <span class="fa fa-warning me-r text-warning"></span>
                                <span x-text="i18n('framework_is_not_machinable')"></span>
                            </p>
                            <div class="d-flex justify-content-left justify-content-lg-center">
                                <div style="width:calc(100% - 36px); max-width:850px;" class="position-relative">
                                    <!-- Export to -->
                                    <div x-show="draw_zome" class="ps-2 absolute-top-right-48" style="top:48px;">
                                        <div class="vstack">
                                            <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                                  data-bs-toggle="tooltip"
                                                  :title="i18n('tooltip_export_2_format', 'GLTF (Meters)')"
                                                  @click="download_gltf()">
                                                <i class="fa-solid fa-file"></i>
                                                <span class="fa-icon-file-type">GLTF</span>
                                            </span>
                                            <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                                  data-bs-toggle="tooltip"
                                                  :title="i18n('tooltip_export_2_format', 'SCAD')"
                                                  @click="download_sca()">
                                                <i class="fa-solid fa-file"></i>
                                                <span class="fa-icon-file-type">SCAD</span>
                                            </span>
                                            <div class="vstack position-relative">
                                                <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                                      data-bs-toggle="tooltip"
                                                      :title="i18n('tooltip_export_2_format', 'OBJ (Millimeters)')"
                                                      @click="download_obj()">
                                                    <i class="fa-solid fa-file"></i>
                                                    <span class="fa-icon-file-type">OBJ</span>
                                                </span>
                                                <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                                      data-bs-toggle="tooltip"
                                                      :title="i18n('tooltip_export_2_format', 'STL (Millimeters)')"
                                                      @click="download_stl()">
                                                    <i class="fa-solid fa-file"></i>
                                                    <span class="fa-icon-file-type">STL</span>
                                                </span>
                                                <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                                      data-bs-toggle="tooltip"
                                                      :title="i18n('tooltip_export_2_format', 'PLY (Millimeters)')"
                                                      @click="download_ply()">
                                                    <i class="fa-solid fa-file"></i>
                                                    <span class="fa-icon-file-type">PLY</span>
                                                </span>
                                                <div
                                                     class="position-absolute end-0 align-items-center"
                                                     :class="(parts_are_separated_for_export) ? 'd-flex' : 'd-none'"
                                                     style="height: 143px; top:12px; right: -22px !important;padding-left: 4px;border-style: none none none dashed;border-color: #80808052;color: #80808052;">
                                                    <i class="fa fa-scalpel-line-dashed"></i>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="mb-2">
                                        <!-- Draw Zome Env/ Zome Skeleton/ Mandala -->
                                        <select class="form-select" aria-label="Type of 3D objects"
                                                x-model="type_of_3D_objects">
                                            <option selected value="skeleton"
                                                    x-text="i18n('skeleton')"></option>
                                            <option value="inner_faces"
                                                    x-text="i18n('inner_faces')"></option>
                                            <option value="outer_faces"
                                                    x-text="i18n('outer_faces')"></option>
                                            <option value="timber_profiles_grouped_by_hash"
                                                    x-text="i18n('timber_profiles')"></option>
                                            <option value="timbers_grouped_by_face"
                                                    x-text="i18n('timbers_of_each_face')"></option>
                                            <option value="inner_faces_grouped_by_hash"
                                                    x-text="i18n('inner_faces_on_the_ground')"></option>
                                            <option value="outer_faces_grouped_by_hash"
                                                    x-text="i18n('outer_faces_on_the_ground')"></option>
                                            <option value="flattened_faces"
                                                    x-text="i18n('flattened_zome')"></option>
                                        </select>
                                    </div>

                                    <!-- Canvas for Zome 3D rendering -->
                                    <div x-ref="rendering_container_3D" class="position-relative">
                                        <div x-ref="canvas_container_3D" style="height:580px; cursor: move;"
                                             :style="(is_fullscreen)? `height:100%;` : `height:580px;`"
                                             class="shadow bg-dark rounded mb-2 overflow-hidden">
                                        </div>

                                        <div x-show="openscad_panel_is_hidden">
                                            <div class="position-absolute end-0 top-0 p-2 d-grid flex-column gap-3">
                                                <!-- Draw Labels -->
                                                <button class="btn btn-primary"
                                                        @click="draw_labels = !draw_labels"
                                                        :class="(draw_labels) ? `btn-primary` : `btn-secondary`"
                                                        data-bs-toggle="tooltip" :title="i18n('tooltip_draw_labels')">
                                                    <i class="fa fa-tag"></i>
                                                </button>

                                                <!-- Num Spirals to display -->
                                                <div class="vstack">
                                                    <button class="btn btn-primary"
                                                            @click="draw_zome = !draw_zome"
                                                            :class="(draw_zome) ? `btn-primary` : `btn-secondary`"
                                                            data-bs-toggle="tooltip"
                                                            :title="i18n('tooltip_illuminate_object')">
                                                        <i class="fa"
                                                           :class="(draw_zome) ? `fa-lightbulb-on` : `fa-lightbulb`"></i>
                                                    </button>
                                                    <div class="mt-1" x-show="draw_zome && clone_and_rotate_items">
                                                        <button class="btn btn-sm btn-small-padding"
                                                                @click="num_spirals_to_display = Math.max(num_spirals_to_display - 1, 1)"
                                                                :class="(num_spirals_to_display <= 1) ? `btn-secondary` : `btn-primary`"
                                                                data-bs-toggle="tooltip"
                                                                :title="i18n('tooltip_decrease_spiral_rotations')">
                                                            <i class="fa fa-minus"></i>
                                                        </button>
                                                        <button class="btn btn-sm btn-small-padding"
                                                                @click="num_spirals_to_display = Math.min(num_spirals_to_display + 1, params.num_spirals)"
                                                                :class="(num_spirals_to_display >= params.num_spirals) ? `btn-secondary` : `btn-primary`"
                                                                data-bs-toggle="tooltip"
                                                                :title="i18n('tooltip_increase_spiral_rotations')">
                                                            <i class="fa fa-plus"></i>
                                                        </button>
                                                    </div>
                                                </div>

                                                <!-- Add floor -->
                                                <button x-show="show_add_floor_btn" class="btn btn-primary"
                                                        @click="add_floor = !add_floor"
                                                        :class="(add_floor) ? `btn-primary` : `btn-secondary`"
                                                        data-bs-toggle="tooltip" :title="i18n('tooltip_add_floor')">
                                                    <i class="fa fa-hexagon"></i>
                                                </button>

                                                <!-- Inversion of Z and Y axes -->
                                                <button class="btn px-0 btn-primary"
                                                        @click="inverse_Y_Z_axes = !inverse_Y_Z_axes"
                                                        :class="(inverse_Y_Z_axes) ? `btn-primary` : `btn-secondary`"
                                                        data-bs-toggle="tooltip"
                                                        :title="i18n('tooltip_inversion_Y_Z_axes')">
                                                    <small>Y⬄Z</small>
                                                </button>

                                                <!-- Zome reflection -->
                                                <button x-show="clone_and_rotate_items"
                                                        class="btn px-0 position-relative btn-primary"
                                                        @click="add_zome_reflection = !add_zome_reflection"
                                                        :class="(add_zome_reflection) ? `btn-primary` : `btn-secondary`"
                                                        data-bs-toggle="tooltip"
                                                        :title="i18n('tooltip_add_zome_reflection')">
                                                    <i class="fa fa-caret-up position-absolute top-0 start-50 translate-middle-x"></i>
                                                    <i class="fa fa-caret-down position-absolute bottom-0 start-50 translate-middle-x"></i>
                                                    <i class="fa fa-horizontal-rule"></i>
                                                </button>

                                                <!-- Parts are stored in separate files -->
                                                <button x-show="!is_fullscreen"
                                                        class="btn btn-primary"
                                                        @click="parts_are_separated_for_export = !parts_are_separated_for_export"
                                                        :class="(parts_are_separated_for_export) ? `btn-primary` : `btn-secondary`"
                                                        data-bs-toggle="tooltip"
                                                        :title="i18n('tooltip_parts_are_stored_in_separate_files')">
                                                    <i class="fa fa-scalpel-line-dashed"></i>
                                                </button>

                                                <!-- Spin on/off -->
                                                <div class="vstack">
                                                    <button class="btn btn-primary"
                                                            @click="is_spinning = !is_spinning"
                                                            :class="(is_spinning) ? `btn-primary` : `btn-secondary`"
                                                            data-bs-toggle="tooltip" :title="i18n('tooltip_spin')">
                                                        <i class="fa "
                                                           :class="(speed < 0) ? `fa-rotate-left` : `fa-rotate-right`"
                                                        ></i>
                                                    </button>

                                                    <!-- Rotation Speed -->
                                                    <div class="mt-1" x-show="is_spinning">
                                                        <button class="btn btn-sm btn-primary btn-small-padding"
                                                                @click="decrease_speed"
                                                                data-bs-toggle="tooltip"
                                                                :title="i18n('key_div_3D_view')">
                                                            <i class="fa fa-minus"></i>
                                                        </button>
                                                        <button class="btn btn-sm btn-primary btn-small-padding"
                                                                @click="increase_speed"
                                                                data-bs-toggle="tooltip"
                                                                :title="i18n('key_mul_3D_view')">
                                                            <i class="fa fa-plus"></i>
                                                        </button>
                                                    </div>
                                                </div>
                                            </div>

                                            <div class="position-absolute bottom-0 p-2 d-flex justify-content-center w-100">
                                                <div class="hstack gap-3">
                                                    <!-- Draw Vanishing Lines -->
                                                    <button x-show="show_vanishing_lines_toggle_btn" class="btn btn-primary"
                                                            @click="draw_vanishing_lines = !draw_vanishing_lines"
                                                            :class="(draw_vanishing_lines) ? `btn-primary` : `btn-secondary`"
                                                            data-bs-toggle="tooltip"
                                                            :title="i18n('tooltip_draw_vanishing_lines')">
                                                        <i class="fa fa-arrows-to-circle"></i>
                                                    </button>

                                                    <!-- Draw Axes -->
                                                    <button class="btn btn-primary"
                                                            @click="draw_axes = !draw_axes"
                                                            :class="(draw_axes) ? `btn-primary` : `btn-secondary`"
                                                            data-bs-toggle="tooltip" :title="i18n('tooltip_draw_axes')">
                                                        <i class="fa fa-chart-scatter-3d"></i>
                                                    </button>
                                                </div>

                                            </div>

                                            <div class="position-absolute start-0 bottom-0 p-2 d-grid flex-column gap-3">
                                                <!-- Capture image -->
                                                <button class="btn btn-primary"
                                                        @click="capture"
                                                        data-bs-toggle="tooltip"
                                                        :title="i18n('tooltip_download_3D_view_in_png_format')">
                                                    <i class="fa fa-camera-retro"></i>
                                                </button>

                                                <!-- Keyboard shortcuts -->
                                                <div data-bs-toggle="modal"
                                                     data-bs-target="#shortcuts-modal">
                                                    <div class="btn btn-primary" data-bs-toggle="tooltip"
                                                         :title="i18n('tooltip_show_keyboard_shortcuts')">
                                                        <i class="fa-solid fa-keyboard"></i>
                                                    </div>
                                                </div>

                                                <!-- Fullscreen Toggle btn -->
                                                <button class="btn btn-primary"
                                                        x-show="can_use_screenfull"
                                                        @click="toggle_fullscreen"
                                                        data-bs-toggle="tooltip" :title="i18n('fullscreen')">
                                                    <i class="fa fa-expand"></i>
                                                </button>
                                            </div>
                                        </div>

                                        <div x-show="!is_fullscreen">
                                            <!-- OpenSCAD Script -->
                                            <div class="position-absolute bottom-0 start-0 w-100"
                                                x-show="!openscad_panel_is_hidden">
                                                <pre class="d-flex m-0">
                                                    <code class="language-scad rounded w-100 overflow-auto bg-transparent"
                                                          style="height:580px;"
                                                        x-text="openscad_content">
                                                    </code>
                                                </pre>
                                            </div>

                                            <div class="position-absolute end-0 bottom-0 p-2 d-grid flex-column gap-3">
                                                <!-- OpenSCAD Btn -->
                                                <div data-bs-toggle="modal"
                                                     data-bs-target="#openscad-modal">
                                                    <div class="btn btn-primary position-relative"
                                                         data-bs-toggle="tooltip"
                                                         @click="openscad_panel_is_hidden = !openscad_panel_is_hidden"
                                                         :class="(!openscad_panel_is_hidden) ? `bg-primary`: `bg-secondary`"
                                                         :title="i18n('show_openscad_script')">
                                                        <img src="img/openscad.svg" alt="openscad" style="width:20px">
                                                    </div>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- Keyboard shortcuts Modal -->
                                        <div class="modal fade" id="shortcuts-modal" tabindex="-1"
                                             aria-labelledby="shortcuts-modal-title" aria-hidden="true">
                                            <div class="modal-dialog modal-sm mt-2 ms-2">
                                                <div class="modal-content">
                                                    <div class="modal-header">
                                                        <h5 class="text-secondary my-1 me-3" id="shortcuts-modal-title">
                                                            <i class="fa-solid fa-keyboard me-1"></i>
                                                            <span x-text="i18n('keyboard_shortcuts')"></span>
                                                        </h5>
                                                        <button type="button" class="btn-close" data-bs-dismiss="modal"
                                                                aria-label="Close"></button>
                                                    </div>
                                                    <div class="modal-body">
                                                        <ul class="keyboard-shortcut-list small text-muted">
                                                            <!-- Object selection -->
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('S')">S
                                                                </button>
                                                                <span x-text="i18n('skeleton')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('O')">O
                                                                </button>
                                                                <span x-text="i18n('outer_faces')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('I')">I
                                                                </button>
                                                                <span x-text="i18n('inner_faces')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('T')">T
                                                                </button>
                                                                <span x-text="i18n('timber_profiles')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('C')">C
                                                                </button>
                                                                <span x-text="i18n('timbers_of_each_face')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('K')">K
                                                                </button>
                                                                <span x-text="i18n('inner_faces_on_the_ground')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('L')">L
                                                                </button>
                                                                <span x-text="i18n('outer_faces_on_the_ground')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('F')">F
                                                                </button>
                                                                <span x-text="i18n('flattened_faces')"></span>
                                                            </li>
                                                            <!-- Camera view -->
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('H')">H
                                                                </button>
                                                                <span x-text="i18n('key_H_3D_view')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('Left')">←
                                                                </button>
                                                                <span x-text="i18n('key_left_3D_view')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('Up')">↑
                                                                </button>
                                                                <span x-text="i18n('key_up_3D_view')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('Right')">→
                                                                </button>
                                                                <span x-text="i18n('key_right_3D_view')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('Down')">↓
                                                                </button>
                                                                <span x-text="i18n('key_down_3D_view')"></span>
                                                            </li>

                                                            <!-- Object rotation -->
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key key-space me-2"
                                                                        @click="keydown(' ')"></button>
                                                                <span x-text="i18n('key_space_3D_view')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('*')">*
                                                                </button>
                                                                <span x-text="i18n('key_mul_3D_view')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('/')">/
                                                                </button>
                                                                <span x-text="i18n('key_div_3D_view')"></span>
                                                            </li>
                                                        </ul>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                </div>
                            </div>
                            <div>
                                <div class="py-2 px-0 d-flex flex-column">
                                    <div class="d-none">
                                        <!-- Set ids to SVG symbols -->
                                        <svg xmlns="http://www.w3.org/2000/svg">
                                            <symbol id="svg_horizontal_bar" width="26"
                                                    height="26" viewBox="0 0 26 26">
                                                <line y2="13" x2="24" y1="13" x1="2"/>
                                            </symbol>
                                            <symbol id="svg_vertical_bar" width="26" height="26"
                                                    viewBox="0 0 26 26">
                                                <line y2="24" x2="13" y1="2" x1="13"/>
                                            </symbol>

                                            <!-- Rhombus -->
                                            <symbol id="svg_rhombus" width="26" height="26"
                                                    viewBox="0 0 26 26">
                                                <polygon points="13 2, 2 13, 13 24, 24 13"/>
                                            </symbol>

                                            <!-- Horizontal Bar at top -->
                                            <symbol id="svg_horizontal_bar_at_top" width="26" height="26"
                                                    viewBox="0 0 26 26">
                                                <line y2="7.5" x2="18.5" y1="7.5" x1="7.5"/>
                                            </symbol>

                                            <!-- Horizontal Bar at right -->
                                            <symbol id="svg_horizontal_bar_at_right" width="26" height="26"
                                                    viewBox="0 0 26 26">
                                                <line y2="13" x2="24" y1="13" x1="13"/>
                                            </symbol>

                                            <!-- Horizontal Bar at bottom -->
                                            <symbol id="svg_horizontal_bar_at_bottom" width="26" height="26"
                                                    viewBox="0 0 26 26">
                                                <line y2="18.5" x2="18.5" y1="18.5" x1="7.5"/>
                                            </symbol>

                                            <!-- Horizontal Bar at left -->
                                            <symbol id="svg_horizontal_bar_at_left" width="26" height="26"
                                                    viewBox="0 0 26 26">
                                                <line y2="13" x2="13" y1="13" x1="2"/>
                                            </symbol>

                                            <!-- Vertical Bar at top -->
                                            <symbol id="svg_vertical_bar_at_top" width="26" height="26"
                                                    viewBox="0 0 26 26">
                                                <line y2="13" x2="13" y1="2" x1="13"/>
                                            </symbol>

                                            <!-- Vertical Bar at bottom -->
                                            <symbol id="svg_vertical_bar_at_bottom" width="26" height="26"
                                                    viewBox="0 0 26 26">
                                                <line y2="24" x2="13" y1="13" x1="13"/>
                                            </symbol>

                                            <!-- Vertical Bar at left -->
                                            <symbol id="svg_vertical_bar_at_left" width="26" height="26"
                                                    viewBox="0 0 26 26">
                                                <line y2="18.5" x2="7.5" y1="7.5" x1="7.5"/>
                                            </symbol>

                                            <!-- Vertical Bar at right -->
                                            <symbol id="svg_vertical_bar_at_right" width="26" height="26"
                                                    viewBox="0 0 26 26">
                                                <line y2="18.5" x2="18.5" y1="7.5" x1="18.5"/>
                                            </symbol>


                                            <!-- Diagonal Bar at top left -->
                                            <symbol id="svg_diagonal_bar_at_top_left" width="26" height="26"
                                                    viewBox="0 0 26 26">
                                                <line y2="13" x2="13" y1="7.5" x1="7.5"/>
                                            </symbol>

                                            <!-- Diagonal Bar at top right -->
                                            <symbol id="svg_diagonal_bar_at_top_right" width="26" height="26"
                                                    viewBox="0 0 26 26">
                                                <line y2="13" x2="13" y1="7.5" x1="18.5"/>
                                            </symbol>

                                            <!-- Diagonal Bar at bottom left -->
                                            <symbol id="svg_diagonal_bar_at_bottom_left" width="26" height="26"
                                                    viewBox="0 0 26 26">
                                                <line y2="13" x2="13" y1="18.5" x1="7.5"/>
                                            </symbol>

                                            <!-- Diagonal Bar at bottom right -->
                                            <symbol id="svg_diagonal_bar_at_bottom_right" width="26" height="26"
                                                    viewBox="0 0 26 26">
                                                <line y2="13" x2="13" y1="18.5" x1="18.5"/>
                                            </symbol>
                                        </svg>
                                    </div>

                                    <div class="gap-3 d-grid d-md-flex align-items-center m-auto">
                                        <div class="me-3 d-flex">
                                            <div class="w-auto mx-auto input-group input-group-sm"
                                                 style="min-width:180px">
                                                <button class="btn btn-primary text-start" type="button"
                                                        data-bs-toggle="tooltip" :title="i18n('tooltip_selected_crown')"
                                                        data-bs-original-title="Selected crown">
                                                    <i class="fa fa-crown"></i>
                                                </button>
                                                <input class="form-control form-range"
                                                       min="1" :max="num_crowns" step="1" type="range"
                                                       x-model.number="selected_crown"
                                                       id="selected_crown_slider">
                                                <input class="form-control" step="1" type="number"
                                                       style="max-width: 63px"
                                                       x-model.lazy.number="selected_crown">
                                            </div>
                                        </div>

                                        <div class="me-3 text-center">
                                            <div id="btn-rhombus-types-group"
                                                 class="btn-group bg-white" role="group"
                                                 aria-label="Toggle button group">

                                                <btn class="btn btn-primary"
                                                     @click="selected_face_divisions_bitwise_flag = 0"
                                                     :class="(selected_face_divisions_bitwise_flag === 0) ? 'btn-primary' : 'btn-secondary'">
                                                    <svg class="svg_rhombus_icon" width="18" height="18"
                                                         viewBox="0 0 26 26">
                                                        <use href="#svg_rhombus"></use>
                                                    </svg>
                                                </btn>

                                                <btn class="btn btn-primary"
                                                     @click="selected_face_divisions_bitwise_flag = SVG_HORIZONTAL_BAR_BITWISE_FLAG"
                                                     :class="(num_points_of_selected_crown === 3) ? 'btn-secondary disabled' : (selected_face_divisions_bitwise_flag === SVG_HORIZONTAL_BAR_BITWISE_FLAG) ? 'btn-primary' : 'btn-secondary'">
                                                    <svg class="svg_rhombus_icon" width="18" height="18"
                                                         viewBox="0 0 26 26">
                                                        <use href="#svg_horizontal_bar"></use>
                                                        <use href="#svg_rhombus"></use>
                                                    </svg>
                                                </btn>

                                                <btn class="btn btn-primary"
                                                     @click="selected_face_divisions_bitwise_flag = SVG_VERTICAL_BAR_BITWISE_FLAG"
                                                     :class="(selected_face_divisions_bitwise_flag === SVG_VERTICAL_BAR_BITWISE_FLAG) ? 'btn-primary' : 'btn-secondary'">
                                                    <svg class="svg_rhombus_icon" width="18" height="18"
                                                         viewBox="0 0 26 26">
                                                        <use href="#svg_vertical_bar"></use>
                                                        <use href="#svg_rhombus"></use>
                                                    </svg>
                                                </btn>

                                                <btn class="btn btn-primary position-relative"
                                                     :class="(num_points_of_selected_crown !== 4) ? 'btn-secondary disabled' : (![SVG_HORIZONTAL_BAR_BITWISE_FLAG, SVG_VERTICAL_BAR_BITWISE_FLAG, 0].includes(selected_face_divisions_bitwise_flag)) ? 'btn-primary' : 'btn-secondary'"
                                                     data-bs-toggle="modal"
                                                     data-bs-target="#framework-customizer-modal"
                                                     for="btn-custom-rhombus">
                                                    <i class="fa fa-pencil"></i>
                                                    <div class="position-absolute" style="top:-10px;right:-10px">
                                                        <div x-show="crown_of_framework_timbers_is_valid"
                                                             class="badge bg-success rounded-pill p-1">
                                                            <i class="fa fa-circle-check"></i>
                                                        </div>
                                                        <div x-show="!crown_of_framework_timbers_is_valid"
                                                             class="badge bg-danger rounded-pill p-1">
                                                            <i class="fa fa-ban"></i>
                                                        </div>
                                                    </div>
                                                </btn>
                                            </div>
                                        </div>

                                        <div class="d-flex">
                                            <div class="w-auto mx-auto input-group input-group-sm "
                                                 style="min-width:180px"
                                                 :class="(can_use_bindu_ratio)? '': 'invisible'">
                                                <button class="btn btn-primary text-start" type="button"
                                                        data-bs-toggle="tooltip" :title="i18n('tooltip_bindu_ratio')"
                                                        data-bs-original-title="Bindu ratio of the selected crown">
                                                    <i class="fa fa-mosque"></i>
                                                </button>
                                                <input class="form-control form-range"
                                                       min="0.50" max="1.50" step="0.01" type="range"
                                                       @dblclick="selected_bindu_ratio = 1"
                                                       x-model.number="selected_bindu_ratio"
                                                       id="selected_bindu_ratio_slider">
                                                <input class="form-control" step="0.01" type="number"
                                                       style="max-width: 63px"
                                                       x-model.lazy.number="selected_bindu_ratio">
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Framework customizer Modal -->
                                <div class="modal fade" id="framework-customizer-modal" tabindex="-1"
                                     aria-labelledby="framework-customizer-modal-title" aria-hidden="true">
                                    <div class="modal-dialog">
                                        <div class="modal-content">
                                            <div class="modal-header">
                                                <h5 class="text-secondary my-1 me-3"
                                                    id="framework-customizer-modal-title">
                                                    <i class="fa-solid fa-frame rotate-45 me-1"></i>
                                                    <span x-text="i18n('framework_customizer')"></span>
                                                </h5>
                                                <button type="button" class="btn-close" data-bs-dismiss="modal"
                                                        aria-label="Close"></button>
                                            </div>
                                            <div class="modal-body px-1">
                                                <div class="vstack">
                                                    <div class="d-flex justify-content-center m-auto mb-3 w-100">
                                                        <svg id="svg_rhombus_customizer" width="300" height="300"
                                                             viewBox="0 0 26 26">

                                                            <use href="#svg_vertical_bar_at_top"></use>
                                                            <use href="#svg_diagonal_bar_at_top_left"></use>
                                                            <use href="#svg_horizontal_bar_at_left"></use>
                                                            <use href="#svg_diagonal_bar_at_bottom_left"></use>
                                                            <use href="#svg_vertical_bar_at_bottom"></use>
                                                            <use href="#svg_diagonal_bar_at_bottom_right"></use>
                                                            <use href="#svg_horizontal_bar_at_right"></use>
                                                            <use href="#svg_diagonal_bar_at_top_right"></use>

                                                            <use href="#svg_horizontal_bar_at_top"></use>
                                                            <use href="#svg_vertical_bar_at_left"></use>
                                                            <use href="#svg_horizontal_bar_at_bottom"></use>
                                                            <use href="#svg_vertical_bar_at_right"></use>

                                                            <use class="clickable"
                                                                 @click="toggle_framework_timber(0)"
                                                                 :class="is_framework_timber_selected(0) ? 'selected' : ''"
                                                                 href="#svg_vertical_bar_at_top"></use>
                                                            <use class="clickable"
                                                                 @click="toggle_framework_timber(1)"
                                                                 :class="is_framework_timber_selected(1) ? 'selected' : ''"
                                                                 href="#svg_diagonal_bar_at_top_left"></use>
                                                            <use class="clickable"
                                                                 @click="toggle_framework_timber(2)"
                                                                 :class="is_framework_timber_selected(2) ? 'selected' : ''"
                                                                 href="#svg_horizontal_bar_at_left"></use>
                                                            <use class="clickable"
                                                                 @click="toggle_framework_timber(3)"
                                                                 :class="is_framework_timber_selected(3) ? 'selected' : ''"
                                                                 href="#svg_diagonal_bar_at_bottom_left"></use>
                                                            <use class="clickable"
                                                                 @click="toggle_framework_timber(4)"
                                                                 :class="is_framework_timber_selected(4) ? 'selected' : ''"
                                                                 href="#svg_vertical_bar_at_bottom"></use>
                                                            <use class="clickable"
                                                                 @click="toggle_framework_timber(5)"
                                                                 :class="is_framework_timber_selected(5) ? 'selected' : ''"
                                                                 href="#svg_diagonal_bar_at_bottom_right"></use>
                                                            <use class="clickable"
                                                                 @click="toggle_framework_timber(6)"
                                                                 :class="is_framework_timber_selected(6) ? 'selected' : ''"
                                                                 href="#svg_horizontal_bar_at_right"></use>
                                                            <use class="clickable"
                                                                 @click="toggle_framework_timber(7)"
                                                                 :class="is_framework_timber_selected(7) ? 'selected' : ''"
                                                                 href="#svg_diagonal_bar_at_top_right"></use>
                                                            <use class="clickable"
                                                                 @click="toggle_framework_timber(8)"
                                                                 :class="is_framework_timber_selected(8) ? 'selected' : ''"
                                                                 href="#svg_horizontal_bar_at_top"></use>
                                                            <use class="clickable"
                                                                 @click="toggle_framework_timber(9)"
                                                                 :class="is_framework_timber_selected(9) ? 'selected' : ''"
                                                                 href="#svg_vertical_bar_at_left"></use>
                                                            <use class="clickable"
                                                                 @click="toggle_framework_timber(10)"
                                                                 :class="is_framework_timber_selected(10) ? 'selected' : ''"
                                                                 href="#svg_horizontal_bar_at_bottom"></use>
                                                            <use class="clickable"
                                                                 @click="toggle_framework_timber(11)"
                                                                 :class="is_framework_timber_selected(11) ? 'selected' : ''"
                                                                 href="#svg_vertical_bar_at_right"></use>

                                                            <use class="selected" href="#svg_rhombus"></use>
                                                            <circle cx="13" cy="13" r="0.01"/>
                                                        </svg>
                                                    </div>

                                                    <div class="mx-auto mb-3">
                                                        <div x-show="crown_of_framework_timbers_is_valid"
                                                             class="badge bg-success rounded-pill">
                                                            <i class="fa fa-circle-check me-1"></i>
                                                            <span x-text="i18n('valid')"></span>
                                                        </div>
                                                        <div x-show="!crown_of_framework_timbers_is_valid"
                                                             class="badge bg-danger rounded-pill">
                                                            <i class="fa fa-ban me-1"></i>
                                                            <span x-text="i18n('not_allowed')"></span>
                                                        </div>
                                                    </div>


                                                    <div class="input-group input-group-sm mx-auto w-auto">
                                                            <span class="btn btn-secondary p-1 mb-3"
                                                                  style="cursor:initial;"></span>
                                                        <template
                                                                x-for="(svg_name, i) in FRAMEWORK_CUSTOMIZER_SVG_IDS"
                                                                :key="i">
                                                            <button class="btn btn-primary mb-3"
                                                                    :class="is_framework_timber_selected(i) ? 'btn-primary' : 'btn-secondary'"
                                                                    @click="toggle_framework_timber(i)"
                                                                    type="button">
                                                                <svg class="svg_rhombus_icon" width="18" height="18"
                                                                     viewBox="0 0 26 26">
                                                                    <use href="#svg_rhombus"></use>
                                                                    <use :href="svg_name"></use>
                                                                </svg>
                                                            </button>
                                                        </template>
                                                        <span class="btn btn-secondary p-1 mb-3"
                                                              style="cursor:initial;"></span>
                                                    </div>

                                                    <div class="input-group input-group-sm w-75 mx-auto">
                                                        <button class="btn btn-primary text-start" type="button"
                                                                data-bs-toggle="tooltip"
                                                                :title="i18n('tooltip_selected_crown')"
                                                                data-bs-original-title="Selected crown">
                                                            <i class="fa fa-crown"></i>
                                                        </button>
                                                        <input class="form-control form-range"
                                                               min="1" :max="num_crowns" step="1" type="range"
                                                               x-model.number="selected_crown">
                                                        <input class="form-control" step="1" type="number"
                                                               style="max-width: 63px"
                                                               x-model.lazy.number="selected_crown">
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                            </div>
                        </div>
                        <div class="tab-pane" id="nav-print" role="tabpanel" aria-labelledby="nav-print-tab"
                             tabindex="0"
                             x-data="renderer_a4" @zome-is-made.window="__process">
                            <div id="renderer_a4_container" class="d-flex justify-content-center"
                                 style="max-width: calc(100% - 36px); ">
                                <div class="position-relative">
                                    <!-- Export to -->
                                    <div class="ps-2 absolute-top-right-48" style="top:48px;">
                                        <div class="vstack">
                                            <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                                  data-bs-toggle="tooltip"
                                                  :title="i18n('tooltip_export_2_format', 'SVG')"
                                                  @click="download_svg()">
                                                <i class="fa-solid fa-file"></i>
                                                <span class="fa-icon-file-type">SVG</span>
                                            </span>
                                            <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                                  data-bs-toggle="tooltip"
                                                  :title="i18n('tooltip_export_2_format', 'PDF')"
                                                  @click="download_pdf()">
                                                <i class="fa-solid fa-file"></i>
                                                <span class="fa-icon-file-type">PDF</span>
                                            </span>
                                        </div>
                                    </div>

                                    <div class="mb-2">
                                        <select class="form-select" aria-label="Kind of drawing"
                                                x-model="kind_of_drawing">
                                            <option selected value="flattened_zome" x-text="i18n('zome')"></option>
                                            <option value="flattened_spirals" x-text="i18n('spirals')"></option>
                                        </select>
                                    </div>

                                    <div class="ratio ratio-A4 bg-white rounded border position-relative">
                                        <!-- Svg Drawing -->
                                        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"
                                             viewbox="0 0 210 297" x-ref="A4_sheet">
                                        </svg>

                                        <!-- Grid Drawing -->
                                        <div class="position-absolute top-0 start-0" x-show="num_col > 1">
                                            <template x-for="(i, j) in  _.range(0, num_col * num_col )" :key="j">
                                                <div class="float-start border border-top-0 border-start-0"
                                                     :class="(((i + 1) % num_col == 0) ? 'border-end-0' : '')
                                                 + ((i >= num_col * (num_col - 1)) ? ' border-bottom-0' : '')"
                                                     :style="`width: ${grid_pct}%; height: ${grid_pct}%;`">
                                                </div>
                                            </template>
                                        </div>
                                    </div>

                                    <div class="input-group input-group-sm mt-2">
                                        <!-- Draw color -->
                                        <button class="btn btn-primary" type="button"
                                                data-bs-toggle="tooltip" :title="i18n('tooltip_draw_face_colors')"
                                                :class="draw_color ? '' : 'btn-secondary'"
                                                @click="draw_color = !draw_color">
                                            <i class="fa-regular fa-droplet fa-fw"></i>
                                        </button>

                                        <!-- Paint Button -->
                                        <button @click="paint_similar_pieces = !paint_similar_pieces"
                                                class="btn btn-primary"
                                                x-show="draw_color"
                                                data-bs-toggle="tooltip" :title="i18n('help_painting_param')">
                                            <i class="fa-solid"
                                               :class="(paint_similar_pieces)? `fa-paintbrush` : `fa-paint-roller`">
                                            </i>
                                        </button>

                                        <!-- Draw centroid -->
                                        <button class="btn btn-primary" type="button"
                                                data-bs-toggle="tooltip" :title="i18n('tooltip_draw_face_centroids')"
                                                :class="draw_centroid ? '' : 'btn-secondary'"
                                                @click="draw_centroid = !draw_centroid">
                                            <i class="fa-regular fa-circle-dot fa-fw"></i>
                                        </button>

                                        <!-- Zoom Level -->
                                        <span class="input-group-text" data-bs-toggle="tooltip" title="Zoom level">
                                        <i class="fa-solid fa-magnifying-glass"></i>
                                    </span>
                                        <input class="form-control form-range" min="0.1" max="1" step="0.01"
                                               type="range"
                                               x-model.number="zoom" x-ref="zoom_slider">

                                        <!-- Num Col of Grid -->
                                        <button class="btn btn-primary" type="button"
                                                data-bs-toggle="tooltip"
                                                :title="i18n('tooltip_split_drawing')"
                                                @click="num_col = (num_col * 2 > 8) ? 1 : num_col * 2">
                                            <i class="fa-regular fa-grid-2-plus fa-fw"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                            <div class="d-flex flex-wrap justify-content-center m-2 me-auto"
                                 style="max-height: 96px;overflow-y: auto;">
                                <template x-for="(color, i) in bulleted_list_colors" :key="i">
                                    <div class="px-1" @click="page_index = i">
                                        <div class="bulleted_list_item"
                                             :class="(page_index == i)? 'active' : ''"
                                             :style="`background-color: ${color};`"></div>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="col-12 break-before" x-data="face_measurements" @zome-is-made.window="__process">
                    <hr>
                    <div class="d-flex flex-column flex-sm-row align-items-center justify-content-between">
                        <h5 class="text-secondary mt-4 mb-4 me-2">
                            <i class="fa-solid fa-ruler-triangle me-1"></i>
                            <span x-text="i18n('measurements')"></span>
                        </h5>

                        <!-- Select inner or outer faces -->
                        <select id="face-measurement-select" class="form-select mx-2" aria-label="Type of 3D objects"
                                style="max-width:200px"
                                x-model="type_of_faces">
                            <option selected value="outer_faces"
                                    x-text="i18n('outer')"></option>
                            <option value="inner_faces"
                                    x-text="i18n('inner')"></option>
                        </select>

                        <!-- TSV and CSV Button -->
                        <div>
                            <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                  data-bs-toggle="tooltip"
                                  :title="i18n('tooltip_export_2_format', 'TSV')"
                                  @click="download_tsv()">
                                <i class="fa-solid fa-file"></i>
                                <span class="fa-icon-file-type">TSV</span>
                            </span>
                            <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                  data-bs-toggle="tooltip"
                                  title="Export to CSV format"
                                  :title="i18n('tooltip_export_2_format', 'CSV')"
                                  @click="download_csv()">
                                <i class="fa-solid fa-file"></i>
                                <span class="fa-icon-file-type">CSV</span>
                            </span>
                        </div>
                    </div>

                    <div class="row justify-content-center">
                        <div class="col-md-12 col-lg-4 mt-2 mx-auto" style="max-width:500px">
                            <p x-text="i18n('zome')" class="text-secondary m-1 up-first"></p>
                            <ul class="list-group small">
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <span x-text="i18n('actual_zome_height')"></span>
                                    <span class="badge bg-info rounded-pill" x-text="actual_zome_height"></span>
                                </li>
                                <li x-show.important="has_floor"
                                    class="list-group-item d-flex justify-content-between align-items-center">
                                    <span x-text="i18n('floor_area')"></span>
                                    <span class="badge bg-info rounded-pill" x-text="floor_area"></span>
                                </li>
                                <li x-show.important="has_floor"
                                    class="list-group-item d-flex justify-content-between align-items-center">
                                    <span x-text="i18n('floor_radius')"></span>
                                    <span class="badge bg-info rounded-pill" x-text="floor_radius"></span>
                                </li>
                            </ul>
                        </div>
                        <div class="col-md-6 col-lg-4 mt-2 mx-auto" style="max-width:500px">
                            <p x-text="i18n('faces')" class="text-secondary m-1 up-first"></p>
                            <ul class="list-group small">
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <span x-text="i18n('num_of_different_faces')"></span>
                                    <span class="badge bg-info rounded-pill" x-text="num_of_different_faces"></span>
                                </li>
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <span x-text="i18n('total_number_of_faces')"></span>
                                    <span class="badge bg-info rounded-pill" x-text="total_number_of_faces"></span>
                                </li>
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <span x-text="i18n('widest_radius_of_faces')"></span>
                                    <span class="badge bg-info rounded-pill" x-text="widest_radius_of_faces"></span>
                                </li>
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <span x-text="i18n('total_area_of_faces')"></span>
                                    <span class="badge bg-info rounded-pill" x-text="total_area_of_faces"></span>
                                </li>
                            </ul>
                        </div>
                        <div class="col-md-6 col-lg-4 mt-2 mx-auto" style="max-width:500px">
                            <p x-text="i18n('timbers')" class="text-secondary m-1 up-first"></p>
                            <ul class="list-group small">
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <span x-text="i18n('num_of_different_timbers')"></span>
                                    <span class="badge bg-info rounded-pill" x-text="num_of_different_timbers"></span>
                                </li>
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <span x-text="i18n('total_number_of_timbers')"></span>
                                    <span class="badge bg-info rounded-pill" x-text="total_number_of_timbers"></span>
                                </li>
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <span x-text="i18n('timber_lengths')"></span>
                                    <span class="badge bg-info rounded-pill" x-text="timber_lengths"></span>
                                </li>
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <span x-text="i18n('total_length_of_timbers')"></span>
                                    <span class="badge bg-info rounded-pill" x-text="total_length_of_timbers"></span>
                                </li>
                            </ul>
                        </div>
                        <div class="col-12 mt-5 mb-5">
                            <div class="table-responsive border border-bottom-0 bg-white rounded">
                                <table x-ref="dim-table"
                                       class="table text-center table-sm small table-striped-order m-0">
                                    <thead class="bg-info text-white">
                                    <tr>
                                        <th></th>
                                        <template x-for="(obj, i) in table_column_names" :key="i">
                                            <th x-text="obj"></th>
                                        </template>
                                    </tr>
                                    </thead>
                                    <tbody>
                                    <template x-for="(row, i) in table_rows" :key="i">
                                        <tr class="align-middle">
                                            <td>
                                                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32"
                                                     :fill="row[0].color.hex">
                                                    <polygon :points="row[0].resize_points_2D(32)"/>
                                                </svg>
                                            </td>
                                            <template x-for="(value, j) in row[1]" :key="j">
                                                <td x-text="value"></td>
                                            </template>
                                        </tr>
                                    </template>
                                    </tbody>
                                    <tfoot>
                                    </tfoot>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="col-12 break-before mb-5" x-data="framework_measurements"
                     @resize.window="__auto_size"
                     @zome-is-made.window="__process">
                    <div class="d-flex flex-column flex-sm-row align-items-center mb-3 justify-content-between">
                        <span class="me-auto"></span>
                        <!-- ZIP and Print Buttons -->
                        <div>
                            <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                  data-bs-toggle="tooltip"
                                  :title="i18n('tooltip_export_2_format', 'TSV')"
                                  @click="download_tsv()">
                                <i class="fa-solid fa-file"></i>
                                <span class="fa-icon-file-type">TSV</span>
                            </span>
                            <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                  data-bs-toggle="tooltip"
                                  title="Export to CSV format"
                                  :title="i18n('tooltip_export_2_format', 'CSV')"
                                  @click="download_csv()">
                                <i class="fa-solid fa-file"></i>
                                <span class="fa-icon-file-type">CSV</span>
                            </span>
                            <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                  data-bs-toggle="tooltip"
                                  :title="i18n('tooltip_export_2_format', 'ZIP')"
                                  @click="download_zip()">
                                <i class="fa-solid fa-file"></i>
                                <span class="fa-icon-file-type">ZIP</span>
                            </span>
                            <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                  data-bs-toggle="tooltip"
                                  :title="i18n('print')"
                                  @click="print()">
                                <i class="fa-solid fa-print"></i>
                            </span>
                        </div>
                    </div>


                    <div class="table-responsive-lg" x-ref="framework_measurement_svgs_container">
                        <div class="gap-3 d-flex flex-column flex-lg-row justify-content-center">
                            <div class="mx-auto" id="timbers_grouped_by_face_svg_container"
                                 :style="`width:${timbers_grouped_by_face_svg_width}px`">
                                <div class="bg-white rounded border"></div>
                            </div>
                            <div class="mx-auto" id="timber_profiles_svg_container"
                                 :style="`width:${timber_profiles_svg_width}px`">
                                <div class="bg-white rounded border"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="toast-container position-fixed bottom-0 start-0 p-3">
        <div id="live_toast" class="toast fade" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body me-auto" id="toast_msg">
                </div>
                <button type="button" class="btn-close me-2 m-auto" data-bs-dismiss="toast"
                        aria-label="Close"></button>
            </div>
        </div>
    </div>
</div>

<!-- Scripts / Bootstrap 5 runs without jQuery -->
<script src="js/popper.min.js"></script>
<script src="js/bootstrap.min.js"></script>

<!-- Lodash -->
<script src="js/lodash.min.js"></script>

<!-- ThreeJS -->
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.min.js"></script>
<script src="js/OBJExporter.min.js"></script>
<script src="js/STLExporter.min.js"></script>
<script src="js/PLYExporter.min.js"></script>
<script src="js/GLTFExporter.min.js"></script>

<!-- Canvg -->
<script src="js/canvg.min.js"></script>

<!-- PDF Kit -->
<script src="js/pdfkit.min.js"></script>
<script src="js/blobstream.min.js"></script>
<script src="js/svg2pdf.min.js"></script>

<!-- Hammer : Touch events -->
<script src="js/hammer.min.js"></script>

<!-- Clipboard JS -->
<script src="js/clipboard.min.js"></script>

<!-- Screenfull -->
<script src="js/screenfull.min.js"></script>

<!-- JSZip -->
<script src="js/jszip.min.js"></script>

<!-- Highlight.js JS -->
<script src="js/highlight/highlight.min.js"></script>
<script src="js/highlight/languages/openscad.min.js"></script>
<script>hljs.highlightAll();</script>

<!-- i18n Dictionaries -->
<script src="i18n/ar.js?v=1.0.16b05"></script>
<script src="i18n/br.js?v=1.0.16b05"></script>
<script src="i18n/de.js?v=1.0.16b05"></script>
<script src="i18n/es.js?v=1.0.16b05"></script>
<script src="i18n/en.js?v=1.0.16b05"></script>
<script src="i18n/hi.js?v=1.0.16b05"></script>
<script src="i18n/it.js?v=1.0.16b05"></script>
<script src="i18n/ja.js?v=1.0.16b05"></script>
<script src="i18n/fr.js?v=1.0.16b05"></script>
<script src="i18n/pl.js?v=1.0.16b05"></script>
<script src="i18n/ru.js?v=1.0.16b05"></script>
<script src="i18n/se.js?v=1.0.16b05"></script>
<script src="i18n/zh.js?v=1.0.16b05"></script>

<!-- Core JS -->
<script src="js/core.js?v=1.0.16b05"></script>

<!-- Alpine JS -->
<script defer src="js/alpine.min.js"></script>

<script type="text/javascript">
    // Import i18n Dictionaries
    const I18_DEFAULT_LANGUAGE = "en";
    const I18N_LANGUAGES = {
        eg: I18N_AR,
        br: I18N_BR,
        de: I18N_DE,
        es: I18N_ES,
        en: I18N_EN,
        in: I18N_HI,
        it: I18N_IT,
        jp: I18N_JA,
        fr: I18N_FR,
        pl: I18N_PL,
        ru: I18N_RU,
        se: I18N_SE,
        cn: I18N_ZH,
    }

    // Use a global variable to store ZOME data
    let ZOME = new Zome({});

    document.addEventListener('alpine:init', () => {
        let framework_measurement_svgs_container;

        Alpine.data('framework_measurements', () => {
                return {
                    timber_profiles_svg_container: null,
                    timbers_grouped_by_face_svg_container: null,

                    timbers_grouped_by_face_svg_width: 300,
                    timber_profiles_svg_width: 800,

                    // Properties
                    title_font_size: 14,
                    x_padding: 40,
                    font_size: 12,
                    stroke_dash_arr: '4, 4',
                    measurement_line_stroke_dash_arr: '3, 3',

                    // Dynamic properties
                    y_padding: 1,
                    stroke_width: 1,
                    text_padding: 1,

                    __auto_size: null,
                    __process: null,
                    async init() {
                        this.__process = _.debounce(this.process, 1);
                        this.__auto_size = _.debounce(this.auto_size, 1);

                        // Init dynamic properties
                        this.y_padding = this.font_size * 4;
                        this.stroke_width = this.font_size / 10;
                        this.text_padding = this.font_size / 1.5;

                        // Get ref elements
                        this.timber_profiles_svg_container = document.getElementById('timber_profiles_svg_container').getElementsByTagName('div')[0];
                        this.timbers_grouped_by_face_svg_container = document.getElementById('timbers_grouped_by_face_svg_container').getElementsByTagName('div')[0];

                        // Call autosize method
                        framework_measurement_svgs_container = this.$refs.framework_measurement_svgs_container;
                        this.auto_size()
                    },
                    auto_size() {
                        const width = framework_measurement_svgs_container.offsetWidth;
                        if (width >= 992) {
                            this.timbers_grouped_by_face_svg_width = width / 3;
                            this.timber_profiles_svg_width = (width / 3) * 2
                        } else {
                            this.timbers_grouped_by_face_svg_width = Math.max(400, width / 2);
                            this.timber_profiles_svg_width = Math.max(600, width);
                        }
                    },
                    get_labels() {
                        return [
                            ...ZOME.timbers_grouped_by_face,
                            ...ZOME.timber_profiles_grouped_by_hash,
                        ].map(group => group.item.label);
                    },
                    get_svg_elements() {
                        return [
                            ...this.timbers_grouped_by_face_svg_container.getElementsByTagName('svg'),
                            ...this.timber_profiles_svg_container.getElementsByTagName('svg'),
                        ];
                    },
                    get table_column_names() {
                        return [
                            this.i18n('profile'),
                            this.i18n('length'),
                            this.i18n('width'),
                            this.i18n('thickness'),
                            this.i18n('quantity'),
                        ]
                    },
                    get table_rows() {
                        const timber_profiles_grouped_by_hash = ZOME.timber_profiles_grouped_by_hash;
                        const num_items = Object.keys(timber_profiles_grouped_by_hash).length;
                        const rows = new Array(num_items);
                        let i = 0;
                        _.forIn(timber_profiles_grouped_by_hash, group => {
                            const timber = group.item;
                            const timber_on_the_ground = timber.put_on_the_ground()
                            rows[i] = [
                                timber.label,
                                to_decimal_str(timber_on_the_ground.width, 0),
                                to_decimal_str(timber_on_the_ground.height, 0),
                                to_decimal_str(timber_on_the_ground.depth, 0),
                                group.count,
                            ]
                            i++;
                        });
                        return rows;
                    },
                    download_tsv() {
                        this.download_csv("\t", "tsv");
                    },
                    download_csv(sep = ";", fmt = "csv") {
                        const hr = "# ------------------------------\n"

                        // Add comments
                        let obj = hr;
                        obj += `# ${this.i18n('zome_made_with')} Z5omes\n`;
                        obj += `# ${window.location.href}\n`;
                        obj += hr;
                        obj += `# Distance: mm\n`;
                        obj += hr;
                        obj += _.join(this.table_column_names, sep) + "\n"
                        const rows = this.table_rows;
                        _.forEach(rows, row => {
                            obj += _.join(row, sep) + "\n"
                        });

                        const filename = this.gen_filename(`_zome_profile_measurements.${fmt}`);
                        download(filename, `data:text/${fmt}; charset=utf-8,` + encodeURIComponent(obj));
                    },
                    download_zip() {
                        const zip = new JSZip();
                        const svg_elements = this.get_svg_elements();
                        const labels = this.get_labels();
                        for (let i = 0; i < svg_elements.length; i++) {
                            const svg = svg_elements[i].outerHTML;
                            const blob = new Blob([svg.toString()]);
                            zip.file(`${labels[i]}.svg`, blob);
                        }

                        const filename = this.gen_filename(`_2D_Drawings.zip`);
                        zip.generateAsync({type: "blob"}).then(function (content) {
                            save_as(content, filename);
                        });
                    },
                    print() {
                        // Create a new tab
                        const handle = window.open('', 'z5omes_tab');

                        // Add custom style tag
                        const css_style = `
                    <style>
                    @media print {
                        @supports (height: 100dvh) {
                            .drawing-2D{
                                display: flex;
                                justify-content: center;
                                text-align: center;
                                margin: 0!important;
                                width: 100dvw!important;
                                height: 100dvh!important;
                                page-break-before: always!important;
                            }
                            .drawing-2D > svg{
                                margin: auto!important;
                                width: auto!important;
                                max-width: 100%!important;
                                height: auto!important;
                                max-height: 100%!important;
                            }
                        }
                    }
                    </style>`;
                        handle.document.write(css_style)

                        // Get elements
                        const svg_elements = this.get_svg_elements();
                        for (let i = 0; i < svg_elements.length; i++) {
                            const svg = svg_elements[i];
                            handle.document.write(`
                            <div class="drawing-2D">
                                ${svg.outerHTML}
                            </div>
                        `)
                        }
                        handle.document.close();

                        // focus the tab and display print window
                        handle.focus();
                        handle.print();
                    },
                    process() {
                        this.compute_drawing_of_timbers_grouped_by_face();
                        this.compute_drawing_of_timber_profiles();
                    },
                    compute_drawing_of_timber_profiles: function () {
                        const timber_profiles_grouped_by_hash = ZOME.timber_profiles_grouped_by_hash;
                        let framework_is_machinable = true;

                        // Clear content
                        this.timber_profiles_svg_container.innerHTML = "";

                        // Define sides
                        const side_names = ["left", "left", "top", "front"];

                        // Reset boundaries
                        let left_column_max_width = Number.MIN_VALUE,
                            right_column_max_width = Number.MIN_VALUE;

                        // Put side on the ground and define global boundaries
                        let all_labeled_sides = {};
                        _.forIn(timber_profiles_grouped_by_hash, group => {
                            // Take the first element of group
                            const prism = group.item;
                            all_labeled_sides[prism.label] = new Array(side_names.length);

                            // Get min max for front and bottom sides
                            _.forEach(side_names, (side_name, i) => {
                                const side = prism.put_face_on_the_ground(side_name, true, true, (i === 1) ? -TAU_Q : null);
                                switch (i) {
                                    case 0:
                                    case 1:
                                        if (side.width > left_column_max_width) left_column_max_width = side.width;
                                        break;
                                    case 2 :
                                        if (side.width > right_column_max_width) right_column_max_width = side.width;
                                        break;
                                }
                                all_labeled_sides[prism.label][i] = side;
                            });
                        });

                        // Get container width
                        const svg_width = this.timber_profiles_svg_container.parentNode.offsetWidth;

                        // Compute column width
                        const available_width = svg_width - 4 * this.x_padding;
                        const left_column_width = available_width / 6;
                        const right_column_width = left_column_width * 5;
                        const pixel_ratio = left_column_width / left_column_max_width;

                        const left_column_x_start = this.x_padding;
                        const right_column_x_start = left_column_x_start + left_column_width + 2 * this.x_padding;

                        _.forIn(timber_profiles_grouped_by_hash, group => {
                            // Take the item of group
                            const prism = group.item;
                            const sides = all_labeled_sides[prism.label];

                            // Get sides of left and right columns
                            const right_column_sides = sides.slice(2, 4);

                            // Compute sum of side heights of the right column (front and bottom). same as left column
                            const sum_side_height = _.reduce(right_column_sides, (res, side) => res + side.height * pixel_ratio, 0);
                            const svg_height = sum_side_height + 6 * this.y_padding;

                            let draw_y_start, draw_y_end,
                                vertical_line_start, vertical_line_end;

                            // Draw one svg for all sides
                            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                            svg.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns', 'http://www.w3.org/2000/svg');
                            svg.setAttribute('viewBox', `0 0 ${svg_width} ${svg_height}`);

                            let svg_elements_with_priority = [];

                            // Add label title vertically at the left of the svg
                            const text_color = prism.color.add(0, -10, -10).hex;
                            const label_title = svg_text(`${this.i18n('profile')} ${prism.label}`,
                                this.x_padding,
                                this.y_padding,
                                this.title_font_size,
                                text_color,
                            );
                            label_title.setAttribute('text-anchor', 'start');
                            label_title.setAttribute('font-weight', 'bold');
                            label_title.setAttribute('style', 'text-transform: capitalize');
                            svg_elements_with_priority.push([label_title, 19]);

                            // Draw sides
                            _.forEach(sides, (side, i) => {
                                    // Compute y start
                                    const line_y_start = (i % 2 === 0)
                                        ? 0
                                        : draw_y_end + this.y_padding;

                                    const column_width = (i < 2) ? left_column_width : right_column_width;

                                    // Adapt the drawing width of the right column
                                    const adaptive_drawing = (i >= 2 && side.width * pixel_ratio > column_width);
                                    const drawing_width = (adaptive_drawing)
                                        ? column_width
                                        : side.width * pixel_ratio;

                                    const column_padding = (column_width - drawing_width) / 2;
                                    const column_x_start = (i < 2)
                                        ? left_column_x_start + column_padding
                                        : right_column_x_start + column_padding;

                                    if (i !== 0) {
                                        const side_title = svg_text(this.i18n(side_names[i]),
                                            column_x_start + drawing_width / 2,
                                            line_y_start + this.y_padding,
                                            this.title_font_size,
                                        );
                                        side_title.setAttribute('text-anchor', 'middle');
                                        side_title.setAttribute('alignment-baseline', 'center');
                                        side_title.setAttribute('style', 'text-transform: capitalize');
                                        svg_elements_with_priority.push([side_title, 5]);
                                    }
                                    if (i === 0) {
                                        const count_text = svg_text(`X ${group.count}`,
                                            svg_width - this.x_padding,
                                            line_y_start + this.y_padding,
                                            this.title_font_size,
                                            text_color
                                        )
                                        count_text.setAttribute('text-anchor', 'end');
                                        count_text.setAttribute('font-weight', 'bold');
                                        svg_elements_with_priority.push([count_text, 5]);
                                    }

                                    // compute y start for the right side
                                    draw_y_start = line_y_start + 2 * this.y_padding;
                                    draw_y_end = draw_y_start + side.height * pixel_ratio;

                                    // fit points
                                    const fitted_points = side.fitted_points;
                                    const drawing_points = fitted_points.map(p => [
                                        (i < 2 || p[0] < side.width / 2)
                                            ? column_x_start + p[0] * pixel_ratio
                                            : column_x_start + drawing_width - (side.width - p[0]) * pixel_ratio,
                                        draw_y_start + p[1] * pixel_ratio,
                                        0,
                                    ]);

                                    const front_points_3D = drawing_points.slice(0, 4);
                                    const front_points_2D = convert_3D_to_2D(front_points_3D);
                                    const polygon_front = svg_polygon(front_points_2D, this.stroke_width, prism.color.hex, '0.7');
                                    svg_elements_with_priority.push([polygon_front, 10]);

                                    if (i >= 2) {
                                        const behind_points_2D = convert_3D_to_2D(drawing_points.slice(4, 8));
                                        const polygon_behind = svg_polygon(behind_points_2D, this.stroke_width, prism.color.hex, '0.7');
                                        polygon_behind.setAttribute('stroke-dasharray', this.stroke_dash_arr);
                                        svg_elements_with_priority.push([polygon_behind, 9]);
                                    }

                                    // Add label of the polygon only on the front side
                                    if (i === 2) {
                                        const centroid = average(front_points_3D);
                                        const side_label = svg_text(`${side.label}`,
                                            centroid[0],
                                            centroid[1],
                                            this.title_font_size,
                                            'white',
                                        );
                                        side_label.setAttribute('text-anchor', 'middle');
                                        side_label.setAttribute('alignment-baseline', 'center');
                                        side_label.setAttribute('font-weight', 'bold');
                                        add_stroke_behind(side_label, 3 * this.stroke_width);
                                        svg_elements_with_priority.push([side_label, 15]);
                                    }

                                    // Add dotted line at the center to show
                                    // that it's a truncated view of the timber profile
                                    if (adaptive_drawing) {
                                        for (let j = 1; j < 4; j += 2) {
                                            const pt1 = front_points_3D[j], pt2 = front_points_3D[(j + 1) % 4];
                                            const line_center = get_midpoint(pt1, pt2);
                                            const dotted_line_start = point_to(line_center, sub(pt1, pt2), 20);
                                            const dotted_line_end = point_to(line_center, sub(pt2, pt1), 20);

                                            const dotted_line_at_the_center = document.createElementNS("http://www.w3.org/2000/svg", "line");
                                            dotted_line_at_the_center.setAttribute('x1', dotted_line_start[0]);
                                            dotted_line_at_the_center.setAttribute('y1', dotted_line_start[1]);
                                            dotted_line_at_the_center.setAttribute('x2', dotted_line_end[0]);
                                            dotted_line_at_the_center.setAttribute('y2', dotted_line_end[1]);
                                            dotted_line_at_the_center.setAttribute('stroke', 'white');
                                            dotted_line_at_the_center.setAttribute('stroke-opacity', '0.5');
                                            dotted_line_at_the_center.setAttribute('stroke-dasharray', '6 6');
                                            dotted_line_at_the_center.setAttribute('stroke-width', `${2 * this.stroke_width}px`);
                                            svg_elements_with_priority.push([dotted_line_at_the_center, 12]);
                                        }
                                    }

                                    // Compute vertical lines start/end
                                    if (i % 2 === 0) {
                                        vertical_line_start = draw_y_start;
                                    } else {
                                        vertical_line_end = draw_y_end;
                                    }

                                    let rounded_xs = [];
                                    for (let j = 0; j < drawing_points.length; j++) {
                                        const pt = drawing_points[j];
                                        // Connects the opposite vertices of the prism
                                        if (i >= 2 && j < 4) {
                                            const vertices_line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                                            const opposite_pt = drawing_points[(j + 4) % 8]
                                            vertices_line.setAttribute('x1', pt[0]);
                                            vertices_line.setAttribute('y1', pt[1]);
                                            vertices_line.setAttribute('x2', opposite_pt[0]);
                                            vertices_line.setAttribute('y2', opposite_pt[1]);
                                            vertices_line.setAttribute('stroke', 'gray');
                                            vertices_line.setAttribute('stroke-opacity', '0.5');
                                            vertices_line.setAttribute('stroke-dasharray', this.stroke_dash_arr);
                                            vertices_line.setAttribute('stroke-width', `${this.stroke_width}px`);
                                            svg_elements_with_priority.push([vertices_line, 9]);
                                        }


                                        const real_pt = fitted_points[j];
                                        const rounded_x = Math.round(real_pt[0]);
                                        // const rounded_x = ["A", "B", "C", "D", "E", "F", "G", "H"][j];
                                        // const rounded_x = j;
                                        if (!rounded_xs.includes(rounded_x)) {
                                            const is_boundary = rounded_x === 0 || rounded_x === Math.round(side.width);

                                            // Avoid overlapping text
                                            const side_text_padding = (j < 4) ? this.text_padding : this.text_padding * 3;
                                            const measurement_text = svg_text(rounded_x,
                                                pt[0],
                                                (real_pt[1] < side.height / 2)
                                                    ? draw_y_start - side_text_padding
                                                    : draw_y_end + this.font_size + side_text_padding,
                                                this.font_size,
                                            );
                                            measurement_text.setAttribute('text-anchor', 'middle');
                                            measurement_text.setAttribute('font-weight', (is_boundary) ? 'bold' : 'normal');
                                            measurement_text.setAttribute('stroke', 'white');
                                            measurement_text.setAttribute('paint-order', 'stroke');
                                            svg_elements_with_priority.push([measurement_text, 20]);

                                            // Draw vertical lines to get a visual alignment
                                            if (i === 3) {
                                                const vertical_line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                                                vertical_line.setAttribute('x1', pt[0]);
                                                vertical_line.setAttribute('y1', `${vertical_line_start}`);
                                                vertical_line.setAttribute('x2', pt[0]);
                                                vertical_line.setAttribute('y2', `${vertical_line_end}`);
                                                vertical_line.setAttribute('stroke', 'gray');
                                                vertical_line.setAttribute('stroke-opacity', '0.4');
                                                vertical_line.setAttribute('stroke-dasharray', this.measurement_line_stroke_dash_arr);
                                                vertical_line.setAttribute('stroke-width', `${this.stroke_width / 2}px`);
                                                svg_elements_with_priority.push([vertical_line, 11]);
                                            }

                                            // add the rounded value to avoid multiple texts
                                            rounded_xs.push(rounded_x);
                                        }
                                    }

                                    // Unpack points
                                    //    [0, 1, 2, 3, 4, 5, 6, 7]
                                    const [a, b, c, d] = drawing_points;                // with z axis equals to 0
                                    const [A, B, C, D, E, F, G, H] = fitted_points;

                                    // Check if timber profile is machinable
                                    if (i === 1) {
                                        // we check that the edges do not cross
                                        let is_machinable = A[0] < B[0] && D[0] < C[0]
                                            && E[0] < F[0] && H[0] < G[0]
                                            && A[1] < D[1] && B[1] < C[1]
                                            && E[1] < H[1] && F[1] < G[1]

                                        if (is_machinable === false) {
                                            framework_is_machinable = false;

                                            // Add Warning text
                                            const label_title = svg_text(
                                                `⚠️ ${this.i18n("timber_is_not_machinable")}`,
                                                this.x_padding,
                                                this.y_padding - this.text_padding * 2.5,
                                                this.title_font_size,
                                                ORANGE,
                                            );
                                            label_title.setAttribute('text-anchor', 'start');
                                            label_title.setAttribute('font-weight', 'bold');
                                            svg_elements_with_priority.push([label_title, 19]);
                                        }
                                    }

                                    // Compute angles from real points
                                    const base_plane = points_2_plane(A, B, C);

                                    // We display the angle information according to the side
                                    const angles_params = (i < 2)
                                        ? [
                                            [
                                                Math.abs(TAU_Q - angle_between_planes(points_2_plane(A, B, F), points_2_plane(B, C, G))),
                                                point_between(c, b, dist(b, c) / 3), 'middle', GREEN, '∠'
                                            ],
                                            [
                                                Math.abs(TAU_Q - angle_between_planes(points_2_plane(C, D, G), points_2_plane(A, D, E))),
                                                point_between(d, a, dist(d, a) / 3), 'middle', GREEN, '∠'
                                            ],
                                        ] : [
                                            [
                                                Math.abs(TAU_Q - angle_between_points(A, B, C)),
                                                point_between(b, a, dist(b, a) / 5), 'middle', RED, '∠'
                                            ],
                                            [
                                                Math.abs(TAU_Q - angle_between_points(D, C, B)),
                                                point_between(c, d, dist(d, c) / 5), 'middle', RED, '∠'
                                            ],
                                            [
                                                Math.abs(TAU_Q - angle_between_planes(base_plane, points_2_plane(A, B, E))),
                                                point_between(b, a, dist(b, a) / 2), 'middle', BLUE, '∟'
                                            ],
                                            [
                                                Math.abs(TAU_Q - angle_between_planes(base_plane, points_2_plane(C, D, H))),
                                                point_between(c, d, dist(d, c) / 2), 'middle', BLUE, '∟'
                                            ],
                                        ];


                                    if ([0, 1].includes(ZOME.assembly_method) && prism.dihedral_angle) {
                                        const use_goodkarma_method = ZOME.assembly_method === 0;
                                        const no_bevel = use_goodkarma_method && prism.dihedral_angle >= TAU_Q;
                                        const bevel_color = no_bevel ? ORANGE : GREEN;

                                        // Add angle text
                                        if (i >= 2) {
                                            angles_params.push(
                                                [
                                                    Math.abs(TAU_Q - prism.dihedral_angle),
                                                    add([0, this.font_size * 1.75, 0], point_between(b, c, dist(b, c) / 2)),
                                                    'middle',
                                                    bevel_color,
                                                    `${no_bevel ? this.i18n("no_bevel") : this.i18n("bevel")} : ∟`
                                                ],
                                            )
                                        }

                                        // Draw bevel lines
                                        const bevel_line_pt_indexes_for_each_view = (use_goodkarma_method)
                                            ? [
                                                [0, 1],         // left of top view
                                                [0, 1],         // left of front view
                                                [0, 1, 2, 3],   // top view
                                                [0, 4, 7, 3],   // front view
                                            ] : [
                                                [1, 2],         // left of top view
                                                [1, 2],         // left of front view
                                                [1, 2],   // top view
                                                [0, 1, 2, 3],   // front view
                                            ]

                                        if (no_bevel === false) {   // Display the bevel ;)
                                            const bevel_line_pt_indexes = bevel_line_pt_indexes_for_each_view[i];
                                            for (let drawing_pt_index = 0; drawing_pt_index < bevel_line_pt_indexes.length; drawing_pt_index++) {
                                                const pt1 = drawing_points[
                                                    bevel_line_pt_indexes[drawing_pt_index]
                                                    ];
                                                const pt2 = drawing_points[
                                                    bevel_line_pt_indexes[(drawing_pt_index + 1) % bevel_line_pt_indexes.length]
                                                    ];

                                                const bevel_line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                                                bevel_line.setAttribute('x1', pt1[0]);
                                                bevel_line.setAttribute('y1', pt1[1]);
                                                bevel_line.setAttribute('x2', pt2[0]);
                                                bevel_line.setAttribute('y2', pt2[1]);
                                                bevel_line.setAttribute('stroke', bevel_color);
                                                bevel_line.setAttribute('stroke-opacity', '1');
                                                bevel_line.setAttribute('stroke-width', `${this.stroke_width * 2.5}px`);
                                                svg_elements_with_priority.push([bevel_line, 11]);
                                            }
                                        }

                                    }

                                    _.forEach(angles_params, params => {
                                        const [theta, text_pos, anchor, color, icon] = params;

                                        // Do not display angle if it's equal to 0
                                        if (to_decimal(rad2deg(theta), 1) === 0) return;

                                        const theta_deg = humanize_angle(rad2deg(theta));
                                        const angle_text = svg_text(`${icon}${theta_deg}`,
                                            text_pos[0],
                                            text_pos[1],
                                            this.font_size,
                                            color
                                        );
                                        angle_text.setAttribute('text-anchor', anchor);
                                        angle_text.setAttribute('stroke', 'white');
                                        angle_text.setAttribute('stroke-width', '4px');
                                        angle_text.setAttribute('paint-order', 'stroke');
                                        angle_text.setAttribute('font-weight', 'bold');
                                        svg_elements_with_priority.push([angle_text, 21]);
                                    });
                                }
                            )
                            ;

                            // Sort svg elements by priority
                            const svg_elements_sorted_by_priority = _.sortBy(svg_elements_with_priority, item => item[1]);
                            _.forEach(svg_elements_sorted_by_priority, item => {
                                svg.appendChild(item[0]);
                            });

                            this.timber_profiles_svg_container.appendChild(svg);
                        });

                        this.framework_is_machinable = framework_is_machinable;
                    },

                    compute_drawing_of_timbers_grouped_by_face:

                        function () {
                            const timbers_grouped_by_face = ZOME.timbers_grouped_by_face;

                            // Clear content
                            this.timbers_grouped_by_face_svg_container.innerHTML = "";

                            // Reset boundaries
                            let max_width = Number.MIN_VALUE;

                            // Put item on the ground and define global boundaries
                            const num_items = Object.keys(timbers_grouped_by_face).length;
                            const items_put_on_the_ground = new Array(num_items);
                            let item_index = 0;
                            _.forIn(timbers_grouped_by_face, group => {
                                // Take the first element of group and put it on the ground
                                const item = group.item.put_on_the_ground();
                                if (item.width > max_width) max_width = item.width;

                                items_put_on_the_ground[item_index] = item;
                                item_index++;
                            });

                            // Get container width
                            const svg_width = this.timbers_grouped_by_face_svg_container.parentNode.offsetWidth;

                            // Compute column width
                            const available_width = svg_width - this.x_padding * 2;
                            const pixel_ratio = available_width / max_width;

                            item_index = 0;
                            const draw_y_start = this.y_padding * 1.5;

                            _.forIn(timbers_grouped_by_face, group => {
                                    // Take the item and compute height
                                    const item = items_put_on_the_ground[item_index]
                                    const svg_height = item.depth * pixel_ratio + 3 * this.y_padding;

                                    // Draw one svg for all sides
                                    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                                    svg.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns', 'http://www.w3.org/2000/svg');
                                    svg.setAttribute('viewBox', `0 0 ${svg_width} ${svg_height}`);

                                    let svg_elements_with_priority = [];

                                    const num_children = item.children.length;
                                    const draw_x_start = (svg_width - (item.width * pixel_ratio)) / 2;

                                    // Compute boundaries
                                    let top_pt = [null, Number.MAX_VALUE],
                                        right_pt = [Number.MIN_VALUE, null],
                                        bottom_pt = [null, Number.MIN_VALUE],
                                        left_pt = [Number.MAX_VALUE, null];

                                    for (let child_index = 0; child_index < num_children; child_index++) {
                                        const prism = item.children[child_index];
                                        const top_face = prism.get_face("top");

                                        // fit points
                                        const fitted_points = swap_axes(
                                            fit_points(top_face.points, item.x_min, item.y_min, item.z_min),
                                            "XZY"
                                        );

                                        // Compute boundary points for all front faces
                                        for (let i = 0; i < top_face.num_points; i++) {
                                            const [x, y] = fitted_points[i];

                                            if (y < top_pt[1]) top_pt = fitted_points[i];
                                            if (x > right_pt[0]) right_pt = fitted_points[i];
                                            if (y > bottom_pt[1]) bottom_pt = fitted_points[i];
                                            if (x < left_pt[0]) left_pt = fitted_points[i];
                                        }

                                        const drawing_points = fitted_points.map(p => [
                                            draw_x_start + p[0] * pixel_ratio,
                                            draw_y_start + p[1] * pixel_ratio,
                                            0,
                                        ]);

                                        // Draw polygons
                                        const top_points_2D = convert_3D_to_2D(drawing_points);
                                        const polygon_top = svg_polygon(top_points_2D, this.stroke_width, top_face.color.hex, 0.7);
                                        svg_elements_with_priority.push([polygon_top, 10]);

                                        // Compute text rotation angle
                                        const [a, b, c, d] = drawing_points;
                                        const d_is_below_a = c[1] > b[1];
                                        let rotation_angle = rad2deg(
                                            angle_between_points(
                                                [c[0], c[1], 0],
                                                [b[0], b[1], 0],
                                                [b[0] + (d_is_below_a ? 10 : -10), b[1], 0],
                                            ) + (d_is_below_a ? 0 : Math.PI)
                                        )

                                        // Add label of the polygon
                                        const label_position = get_midpoint(top_face.centroid,
                                            get_midpoint(top_face.points[0], top_face.points[2]),
                                        );
                                        const x = draw_x_start + (label_position[0] - item.x_min) * pixel_ratio;
                                        const y = draw_y_start + (label_position[2] - item.z_min) * pixel_ratio; // swap Y <-> Z
                                        const face_label = svg_text(`${top_face.label}`,
                                            0, 0,
                                            this.title_font_size * 0.9,
                                            'white',
                                        );
                                        face_label.setAttribute('text-anchor', 'middle');
                                        face_label.setAttribute('alignment-baseline', 'middle');
                                        face_label.setAttribute('font-weight', 'bold');
                                        face_label.setAttribute('transform', `translate(${x}, ${y}) rotate(${rotation_angle})`);

                                        add_stroke_behind(face_label, 3 * this.stroke_width);
                                        svg_elements_with_priority.push([face_label, 15]);

                                        // Add dihedral angle
                                        const theta = Math.abs(TAU_Q - prism.dihedral_angle);
                                        if (
                                            [0, 1].includes(ZOME.assembly_method)
                                            && to_decimal(rad2deg(theta), 1) !== 0  // Do not display angle if it's equal to 0
                                        ) {
                                            const use_goodkarma_method = ZOME.assembly_method === 0;
                                            const no_bevel = use_goodkarma_method && prism.dihedral_angle >= TAU_Q;

                                            const [bevel_anchor, bevel_color, bevel_icon] = [
                                                'middle',
                                                no_bevel ? ORANGE : GREEN,
                                                `∟`
                                            ]

                                            const middle_of_bc = get_midpoint(b, c);
                                            const b_to_c = sub(c, b);

                                            const perpendicular_vec = [-b_to_c[1], b_to_c[0], b_to_c[2]];
                                            const text_pos = point_to(
                                                middle_of_bc,
                                                perpendicular_vec,
                                                this.text_padding * 2.5
                                            )

                                            const theta_deg = humanize_angle(rad2deg(theta));
                                            const angle_text = svg_text(`${bevel_icon}${theta_deg}`, 0, 0,
                                                this.font_size,
                                                bevel_color
                                            );
                                            angle_text.setAttribute('text-anchor', bevel_anchor);
                                            angle_text.setAttribute('stroke', 'white');
                                            angle_text.setAttribute('stroke-width', '4px');
                                            angle_text.setAttribute('paint-order', 'stroke');
                                            angle_text.setAttribute('transform', `translate(${text_pos[0]}, ${text_pos[1]}) rotate(${rotation_angle})`);
                                            angle_text.setAttribute('font-weight', 'bold');
                                            svg_elements_with_priority.push([angle_text, 21]);


                                            const bevel_line_pt_indexes = (use_goodkarma_method)
                                                ? [0, 1, 2, 3]
                                                : [1, 2];


                                            if (no_bevel === false) {   // Display the bevel ;)
                                                for (let drawing_pt_index = 0; drawing_pt_index < bevel_line_pt_indexes.length; drawing_pt_index++) {
                                                    const pt1 = drawing_points[
                                                        bevel_line_pt_indexes[drawing_pt_index]
                                                        ];
                                                    const pt2 = drawing_points[
                                                        bevel_line_pt_indexes[(drawing_pt_index + 1) % bevel_line_pt_indexes.length]
                                                        ];


                                                    const bevel_line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                                                    bevel_line.setAttribute('x1', pt1[0]);
                                                    bevel_line.setAttribute('y1', pt1[1]);
                                                    bevel_line.setAttribute('x2', pt2[0]);
                                                    bevel_line.setAttribute('y2', pt2[1]);
                                                    bevel_line.setAttribute('stroke', bevel_color);
                                                    bevel_line.setAttribute('stroke-opacity', '1');
                                                    bevel_line.setAttribute('stroke-width', `${this.stroke_width * 2.5}px`);
                                                    svg_elements_with_priority.push([bevel_line, 11]);
                                                }
                                            }
                                        }
                                    }

                                    // Compute drawing boundary points
                                    const drawing_boundary_pts = [
                                        top_pt, right_pt, bottom_pt, left_pt
                                    ].map(p => [
                                        p[0] * pixel_ratio,
                                        p[1] * pixel_ratio,
                                        0,
                                    ]);

                                    const top_left_corner_pt = [
                                        this.x_padding / 4,
                                        draw_y_start
                                    ]
                                    const bottom_right_corner_pt = [
                                        svg_width - this.x_padding / 4,
                                        svg_height - this.y_padding / 2
                                    ]

                                    // Add measurements dashed lines
                                    for (let i = 0; i < drawing_boundary_pts.length; i++) {
                                        const measurement_line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                                        const pt = drawing_boundary_pts[i];

                                        measurement_line.setAttribute('x1', draw_x_start + pt[0]);
                                        measurement_line.setAttribute('y1', draw_y_start + pt[1]);
                                        if (i % 2 === 0) {
                                            measurement_line.setAttribute('x2', bottom_right_corner_pt[0]);
                                            measurement_line.setAttribute('y2', draw_y_start + pt[1]);
                                        } else {
                                            measurement_line.setAttribute('x2', draw_x_start + pt[0]);
                                            measurement_line.setAttribute('y2', bottom_right_corner_pt[1]);
                                        }

                                        measurement_line.setAttribute('stroke', 'gray');
                                        measurement_line.setAttribute('stroke-opacity', '0.4');
                                        measurement_line.setAttribute('stroke-dasharray', this.measurement_line_stroke_dash_arr);
                                        measurement_line.setAttribute('stroke-width', `${this.stroke_width / 2}px`);
                                        svg_elements_with_priority.push([measurement_line, 9]);
                                    }

                                    // Add vertical line and height text
                                    {
                                        const measurement_line = document.createElementNS("http://www.w3.org/2000/svg", "line");

                                        measurement_line.setAttribute('x1', bottom_right_corner_pt[0]);
                                        measurement_line.setAttribute('y1', draw_y_start + drawing_boundary_pts[0][1]);
                                        measurement_line.setAttribute('x2', bottom_right_corner_pt[0]);
                                        measurement_line.setAttribute('y2', draw_y_start + drawing_boundary_pts[2][1]);

                                        measurement_line.setAttribute('stroke', 'gray');
                                        measurement_line.setAttribute('stroke-opacity', '0.4');
                                        measurement_line.setAttribute('stroke-width', `${this.stroke_width}px`);
                                        svg_elements_with_priority.push([measurement_line, 9]);

                                        const height = Math.round(bottom_pt[1]);

                                        const text_pt = [
                                            bottom_right_corner_pt[0] - this.text_padding / 2,
                                            draw_y_start + drawing_boundary_pts[2][1] / 2 + this.text_padding / 2,
                                        ]
                                        const measurement_text = svg_text(`${height}`, 0, 0, this.font_size); // position
                                        measurement_text.setAttribute('text-anchor', 'middle');
                                        measurement_text.setAttribute('font-weight', 'normal');
                                        measurement_text.setAttribute('stroke', 'white');
                                        measurement_text.setAttribute('paint-order', 'stroke');
                                        measurement_text.setAttribute('transform', `translate(${text_pt[0]}, ${text_pt[1]}) rotate(270)`);
                                        measurement_text.setAttribute('font-weight', 'bold');

                                        svg_elements_with_priority.push([measurement_text, 10]);
                                    }

                                    // Add horizontal line and width text
                                    {
                                        const measurement_line = document.createElementNS("http://www.w3.org/2000/svg", "line");

                                        measurement_line.setAttribute('x1', draw_x_start + drawing_boundary_pts[3][0]);
                                        measurement_line.setAttribute('y1', bottom_right_corner_pt[1]);
                                        measurement_line.setAttribute('x2', draw_x_start + drawing_boundary_pts[1][0]);
                                        measurement_line.setAttribute('y2', bottom_right_corner_pt[1]);

                                        measurement_line.setAttribute('stroke', 'gray');
                                        measurement_line.setAttribute('stroke-opacity', '0.4');
                                        measurement_line.setAttribute('stroke-width', `${this.stroke_width}px`);
                                        svg_elements_with_priority.push([measurement_line, 9]);


                                        const width = Math.round(right_pt[0]);
                                        const measurement_text = svg_text(`${width}`,
                                            draw_x_start + drawing_boundary_pts[1][0] / 2,
                                            bottom_right_corner_pt[1] - this.text_padding / 2,
                                            this.font_size,
                                        );
                                        measurement_text.setAttribute('text-anchor', 'middle');
                                        measurement_text.setAttribute('font-weight', 'normal');
                                        measurement_text.setAttribute('stroke', 'white');
                                        measurement_text.setAttribute('paint-order', 'stroke');
                                        measurement_text.setAttribute('font-weight', 'bold');

                                        svg_elements_with_priority.push([measurement_text, 10]);
                                    }


                                    // Add count text
                                    const text_color = item.color.add(0, -10, -10).hex;
                                    const count_text = svg_text(`X ${group.count}`,
                                        svg_width - this.x_padding,
                                        this.y_padding,
                                        this.title_font_size,
                                        text_color,
                                    );
                                    count_text.setAttribute('text-anchor', 'end');
                                    count_text.setAttribute('font-weight', 'bold');
                                    svg_elements_with_priority.push([count_text, 5]);

                                    // Add label title vertically at the left of the svg
                                    const label_title = svg_text(`${this.i18n('face')} ${item.label}`,
                                        this.x_padding,
                                        this.y_padding,
                                        this.title_font_size,
                                        text_color,
                                    );
                                    label_title.setAttribute('text-anchor', 'start');
                                    label_title.setAttribute('font-weight', 'bold');
                                    label_title.setAttribute('style', 'text-transform: capitalize');
                                    svg_elements_with_priority.push([label_title, 19]);

                                    // Sort svg elements by priority
                                    const svg_elements_sorted_by_priority = _.sortBy(svg_elements_with_priority, item => item[1]);
                                    _.forEach(svg_elements_sorted_by_priority, item => {
                                        svg.appendChild(item[0]);
                                    });
                                    this.timbers_grouped_by_face_svg_container.appendChild(svg);
                                    item_index++;
                                }
                            )
                            ;
                        }

                    ,
                };
            }
        )
        ;

        Alpine.data('face_measurements', () => {
            return {
                // Zome properties
                actual_zome_height: 0,

                // Faces properties
                type_of_faces: "outer_faces",
                faces: [],
                face_quantities: [],
                floor: null,
                total_number_of_faces: 0,
                num_of_different_faces: 0,

                // Timber properties
                total_number_of_timbers: 0,
                num_of_different_timbers: 0,
                timber_lengths: 0,
                total_length_of_timbers: 0,

                __process: null,

                async init() {
                    this.__process = _.debounce(this.process, 1);

                    ["type_of_faces"].forEach(
                        (key) => this.$watch(key, () => {
                            this.compute_faces();
                        })
                    );
                },
                get has_floor() {
                    return this.floor !== null;
                },
                get widest_radius_of_faces() {
                    const value = _.reduce(this.faces, (res, p) => Math.max(res, p.radius), Number.MIN_VALUE);
                    return humanize_distance(value);
                },
                get total_area_of_faces() {
                    const value = _.reduce(this.faces, (res, p) => res + p.area * ZOME.num_spirals, 0);
                    return humanize_area(value);
                },
                get floor_radius() {
                    const value = this.floor ? this.floor.radius : 0;
                    return humanize_distance(value);
                },
                get floor_area() {
                    const value = this.floor ? this.floor.area : 0
                    return humanize_area(value);
                },
                get floor_perimeter() {
                    const value = this.floor ? this.floor.perimeter : 0
                    return humanize_distance(value);
                },
                download_tsv() {
                    this.download_csv("\t", "tsv");
                },
                download_csv(sep = ";", fmt = "csv") {
                    const hr = "# ------------------------------\n"

                    // Add comments
                    let obj = hr;
                    obj += `# ${this.i18n('zome_made_with')} Z5omes\n`;
                    obj += `# ${window.location.href}\n`;
                    obj += hr;
                    obj += `# ${this.i18n('actual_zome_height')} : ${this.actual_zome_height}\n`;
                    obj += `# ${this.i18n('floor_area')} : ${this.floor_area}\n`;
                    obj += `# ${this.i18n('floor_radius')} : ${this.floor_radius}\n`;
                    obj += hr;
                    obj += `# ${this.i18n('num_of_different_faces')} : ${this.num_of_different_faces}\n`;
                    obj += `# ${this.i18n('total_number_of_faces')} : ${this.total_number_of_faces}\n`;
                    obj += `# ${this.i18n('widest_radius_of_faces')} : ${this.widest_radius_of_faces}\n`;
                    obj += `# ${this.i18n('total_area_of_faces')} : ${this.total_area_of_faces}\n`;
                    obj += hr;
                    obj += `# ${this.i18n('num_of_different_timbers')} : ${this.num_of_different_timbers}\n`;
                    obj += `# ${this.i18n('total_number_of_timbers')} : ${this.total_number_of_timbers}\n`;
                    obj += `# ${this.i18n('timber_lengths')} : ${this.timber_lengths}\n`;
                    obj += `# ${this.i18n('total_length_of_timbers')} : ${this.total_length_of_timbers}\n`;
                    obj += hr;
                    obj += _.join(this.table_column_names, sep) + "\n"
                    const rows = this.table_rows;
                    _.forEach(rows, row => {
                        obj += _.join(row[1], sep) + "\n"
                    });

                    const filename = this.gen_filename(`_zome_measurements.${fmt}`);
                    download(filename, `data:text/${fmt}; charset=utf-8,` + encodeURIComponent(obj));
                },
                get table_column_names() {
                    return [
                        this.i18n('id'),
                        this.i18n('quantity'),
                        this.i18n('width'),
                        this.i18n('height'),
                        this.i18n('edges'),            // CCW Edges
                        this.i18n('face_angles'),           // CCW Angles
                        this.i18n('dihedral_angle'),   // Dihedral angle with plane above
                        this.i18n('wedge_angle'),      // Wedge angle for Xpansion method
                        this.i18n('slope_angle'),
                        this.i18n('area'),
                        this.i18n('radius'),
                    ]
                },
                get table_rows() {
                    const row_faces = this.has_floor
                        ? [...this.faces, this.floor]
                        : this.faces
                    const rows = new Array(row_faces.length);
                    _.forEach(row_faces, (face, i) => {
                        const face_on_the_ground = face.put_face_on_the_ground("front", true);
                        rows[i] = [face_on_the_ground, [
                            face_on_the_ground.label,
                            this.face_quantities[i] || 1,
                            humanize_distance(face_on_the_ground.width),
                            humanize_distance(face_on_the_ground.height),
                            humanize_arr(unique_arr(_.map(face.edge_distances, v => humanize_distance(v)))),
                            humanize_arr(unique_arr(_.map(face.angles, a => humanize_angle(rad2deg(a))))),
                            humanize_angle(rad2deg(face.dihedral_angle)),
                            humanize_angle(rad2deg(face.dihedral_angle > 0 ? Math.PI - face.dihedral_angle : 0)),
                            humanize_angle(rad2deg(face.normalized_slope)),
                            humanize_area(face.area),
                            humanize_distance(face.radius),
                        ]];
                    });
                    return rows;
                },

                process() {
                    const skeleton = ZOME.skeleton;

                    // Get Zome Height
                    this.actual_zome_height = humanize_distance(ZOME.height);

                    let max_timber_length = Number.MIN_VALUE,
                        min_timber_length = Number.MAX_VALUE,
                        total_length_of_timbers = 0,
                        total_number_of_timbers = 0;

                    const timber_profiles_grouped_by_hash = ZOME.timber_profiles_grouped_by_hash;
                    const num_items = Object.keys(timber_profiles_grouped_by_hash).length;

                    _.forIn(timber_profiles_grouped_by_hash, group => {
                        const timber = group.item;
                        const timber_width = timber.put_on_the_ground().width;
                        if (timber_width > max_timber_length) max_timber_length = timber_width;
                        if (timber_width < min_timber_length) min_timber_length = timber_width;

                        total_length_of_timbers += timber_width * group.count;
                        total_number_of_timbers += group.count;
                    });

                    this.total_length_of_timbers = humanize_distance(total_length_of_timbers);
                    this.timber_lengths = `[${humanize_distance(min_timber_length)}, ${humanize_distance(max_timber_length)}]`;
                    this.num_of_different_timbers = num_items;
                    this.total_number_of_timbers = total_number_of_timbers;

                    this.compute_faces();
                },
                compute_faces() {
                    // Add floor
                    switch (this.type_of_faces) {
                        case "inner_faces":
                            this.floor = ZOME.inner_floor;
                            break;
                        case "outer_faces":
                            this.floor = ZOME.outer_floor;
                            break;
                    }

                    // Add faces
                    const groups = eval(`ZOME.${this.type_of_faces}_grouped_by_hash`);
                    const num_items = Object.keys(groups).length;
                    this.faces = new Array(num_items);
                    this.face_quantities = new Array(num_items);
                    this.num_of_different_faces = num_items;
                    let total_number_of_faces = 0;

                    let face_index = 0;
                    _.forIn(groups, group => {
                        this.faces[face_index] = group.item;
                        this.face_quantities[face_index] = group.count;
                        total_number_of_faces += group.count;
                        face_index++;
                    });

                    this.total_number_of_faces = total_number_of_faces;

                },
            };
        });

        Alpine.data('renderer_a4', () => {
            let svg_elements_per_page = [];
            let pages = [];
            let page_bounds = [];

            return {
                A4_sheet: null,
                num_pages: 0,
                page_index: 0,
                pages: [],
                bulleted_list_colors: [],
                zoom: 1,
                num_col: 1,
                kind_of_drawing: "flattened_zome",
                draw_color: true,
                draw_centroid: false,
                paint_similar_pieces: true,

                __process: null,

                // 2D Rendering Parameters
                init() {
                    this.A4_sheet = this.$refs.A4_sheet;
                    this.__process = _.debounce(this.process, 1);

                    // Add listeners
                    _.forEach(["kind_of_drawing", "paint_similar_pieces"], key => this.$watch(key, () => {
                            this.__process();
                        })
                    );

                    this.$watch("page_index", () => {
                        this.draw();
                    });

                    _.forEach(["zoom", "draw_color", "draw_centroid"], key => this.$watch(key, () => {
                            this.build_elements_per_page();
                            this.draw();
                        })
                    );

                    this.$el.addEventListener("keydown", e => this.keydown(e.key) && e.preventDefault(), false);

                    // Add swipe
                    const hammer = new Hammer(this.A4_sheet.parentNode);
                    hammer.on('swiperight', () => this.prev_page());
                    hammer.on('swipeleft', () => this.next_page());
                },
                get grid_pct() {
                    // Compute Grid size in percent for css drawing
                    return 100 / this.num_col;
                },
                download_pdf() {
                    // Create empty PDF document
                    const [A4_width, A4_height] = [595, 842];
                    const doc = new PDFDocument({compress: false, size: [A4_width, A4_height]});
                    const stream = doc.pipe(blobStream());

                    // Create SVG
                    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    svg.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns', 'http://www.w3.org/2000/svg');
                    svg.setAttribute('viewBox', '0 0 210 297');

                    const size = {width: A4_width * this.num_col, height: A4_height * this.num_col};
                    const num_sheet_per_svg = this.num_col * this.num_col;

                    _.forEach(svg_elements_per_page, (elements, iP) => {
                        // Create the svg with elements
                        svg.innerHTML = '';
                        _.forEach(elements, element => svg.appendChild(element));

                        // Split the drawing into multiple A4 sheets depends on the num_col
                        for (let i = 0; i < num_sheet_per_svg; i++) {
                            for (let j = 0; j < this.num_col; j++) {
                                const x = -j * A4_width;
                                const y = -i * A4_height;
                                SVGtoPDF(doc, svg, x, y, size);

                                // Add page if it's not the last
                                if ((i + 1) * (j + 1) < num_sheet_per_svg - 1) {
                                    doc.addPage()
                                }
                            }
                        }

                        // Add page if it's not the last
                        if (iP < svg_elements_per_page.length - 1) {
                            doc.addPage()
                        }
                    });

                    // Save document
                    doc.end();

                    const filename = this.gen_filename(`_${this.kind_of_drawing}.pdf`);
                    stream.on('finish', function () {
                        const url = stream.toBlobURL("application/pdf");
                        download(filename, url);
                    });

                    // Tricks because svg is empty otherwise ;)
                    this.draw();
                },
                download_svg() {
                    const svg = this.A4_sheet.outerHTML;
                    const blob = new Blob([svg.toString()]);
                    const filename = this.gen_filename(`_${this.kind_of_drawing}.svg`);
                    download(filename, URL.createObjectURL(blob));
                },
                process() {
                    // Init variables
                    pages = [];
                    switch (this.kind_of_drawing) {
                        case 'flattened_spirals':
                            this.draw_flattened_spirals();
                            break;
                        case 'flattened_zome':
                            this.draw_flattened_zome();
                            break;
                    }

                    // Compute boundaries for all pages
                    page_bounds = new Array(pages.length);
                    _.forEach(pages, (page_faces, iP) => {
                        // Reset boundaries
                        let x_max = Number.MIN_VALUE,
                            y_max = Number.MIN_VALUE,
                            x_min = Number.MAX_VALUE,
                            y_min = Number.MAX_VALUE;

                        // Get min max from all faces
                        for (const face of page_faces) {
                            if (face.x_min < x_min) x_min = face.x_min;
                            if (face.x_max > x_max) x_max = face.x_max;
                            if (face.y_min < y_min) y_min = face.y_min;
                            if (face.y_max > y_max) y_max = face.y_max;
                        }

                        const width = Math.abs(x_max - x_min);
                        const height = Math.abs(y_max - y_min);
                        page_bounds[iP] = [x_min, y_min, width, height];
                    });

                    // Add bulleted list
                    const bulleted_list_colors = new Array(pages.length);
                    _.forEach(pages, (page_faces, iP) => {
                        // Add color of the first piece to bulleted list
                        bulleted_list_colors[iP] = page_faces[0].color.hex;
                    });

                    // Save proxies
                    this.bulleted_list_colors = bulleted_list_colors;

                    this.build_elements_per_page();
                    this.page_index = 0;
                    this.draw();
                },
                build_elements_per_page() {
                    // Compute the same pixel ratio for all pages
                    const max_width = _.reduce(page_bounds, (res, arr) => Math.max(res, arr[2]), Number.MIN_VALUE);
                    const max_height = _.reduce(page_bounds, (res, arr) => Math.max(res, arr[3]), Number.MIN_VALUE);
                    const border = 6;
                    const pixel_ratio = Math.min(
                        (210 - 2 * border) / max_width, (297 - 6 * border) / max_height
                    ) * this.zoom;
                    const center = [210 / 2, 297 / 2];

                    // Build pages faces
                    svg_elements_per_page = new Array(pages.length);
                    let iF, points;
                    _.forEach(pages, (page, iPa) => {
                        const num_elements = this.draw_centroid ? page.length * 2 + 1 : page.length + 1;
                        const svg_elements = new Array(num_elements);
                        iF = 0;
                        _.forEach(page, face => {
                            const [xMin, yMin, width, height] = page_bounds[iPa];
                            points = face.points.map(p => [
                                (p[0] - xMin - width / 2) * pixel_ratio + center[0],
                                (p[1] - yMin - height / 2) * pixel_ratio + center[1],
                            ]);

                            const el = svg_polygon(points, 0.1, this.draw_color ? face.color.hex : 'transparent');
                            svg_elements[iF] = el;
                            iF++
                            if (this.draw_centroid) {
                                const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                                const centroid = get_centroid(points);
                                c.setAttribute('cx', `${centroid[0]}`);
                                c.setAttribute('cy', `${centroid[1]}`);
                                c.setAttribute('r', '1');
                                svg_elements[iF] = c;
                                iF++;
                            }
                        });

                        // Add Text
                        const el = svg_text(`Page ${iPa + 1}/${pages.length}`,
                            210 - border,
                            297 - border,
                            6
                        );
                        el.setAttribute('text-anchor', 'end');
                        svg_elements[iF] = el;

                        // Add color of the first piece to bulleted list
                        svg_elements_per_page[iPa] = svg_elements;
                    });
                },
                draw_flattened_zome() {
                    const flattened_faces = ZOME.flattened_faces;

                    // For each color, rotate piece around the origin
                    const flattened_zome = [], O = [0, 0, 0];
                    const first_face = flattened_faces[0];
                    const incr_angle = first_face.is_left_part
                        ? first_face.angles[0] * 2
                        : first_face.angles[0];

                    for (let i = 0, rotation_angle = 0; i < ZOME.num_spirals; i++, rotation_angle += incr_angle) {
                        _.forEach(flattened_faces, (face) => {
                            flattened_zome.push(
                                new Polygon3D(
                                    swap_axes(face.points, "XZY").map(p => rotate_point_around_z_axis(p, -rotation_angle, O)),
                                    face.label,
                                    (this.paint_similar_pieces)
                                        ? face.color
                                        : ZOME.rotated_colors[face.color.hex][i],
                                )
                            );

                        });
                    }

                    if (flattened_zome.length > 0) {
                        pages.push(flattened_zome);
                    }
                },
                draw_flattened_spirals() {
                    const flattened_faces = ZOME.flattened_faces;

                    // For each color, Add a page with outer_faces faces
                    for (let i = 0; i < ZOME.num_spirals; i++) {
                        const colored_flattened_spirals = [];
                        _.forEach(flattened_faces, (face) => {
                            colored_flattened_spirals.push(
                                new Polygon3D(
                                    swap_axes(face.points, "XZY"),
                                    face.label,
                                    (this.paint_similar_pieces)
                                        ? face.color
                                        : ZOME.rotated_colors[face.color.hex][i],
                                )
                            );
                        });
                        pages.push(colored_flattened_spirals);
                    }
                },
                next_page() {
                    this.page_index = (this.page_index + 1) % svg_elements_per_page.length;
                },
                prev_page() {
                    this.page_index = (svg_elements_per_page.length + this.page_index - 1) % svg_elements_per_page.length;
                },
                keydown(key) {
                    switch (key) {
                        case "Up":
                        case "ArrowUp":
                        case "Left":
                        case "ArrowLeft":
                            this.prev_page();
                            break;
                        case "Down":
                        case "ArrowDown":
                        case "Right":
                        case "ArrowRight":
                            this.next_page();
                            break;
                        default:
                            return false;
                    }
                    return true;
                },
                draw() {
                    this.A4_sheet.innerHTML = '';
                    if (svg_elements_per_page.length <= 0) {
                        return;
                    }
                    const elements = svg_elements_per_page[this.page_index % svg_elements_per_page.length];
                    for (const el of elements) {
                        this.A4_sheet.appendChild(el);
                    }
                }
            };
        });

        Alpine.data('renderer_3D', () => {
            // Three JS Objects
            let scene, camera, renderer, controls,
                canvas, canvas_container, font;

            const meshes = {
                "axes": null,
                "zome": null,
                "edges": null,
                "labels": null,
                "vanishing_lines": null,
            }

            return {
                // 3D Rendering Parameters
                num_spirals_to_display: 1,
                last_num_spirals: 1,
                is_spinning: false,
                openscad_panel_is_hidden: true,
                speed: 0.001,
                type_of_3D_objects: "skeleton",
                parts_are_separated_for_export: false,

                draw_zome: true,
                draw_labels: true,
                draw_axes: true,

                draw_vanishing_lines: false,
                show_vanishing_lines_toggle_btn: false,

                add_floor: true,
                show_add_floor_btn: false,

                inverse_Y_Z_axes: false,
                add_zome_reflection: false,

                is_fullscreen: false,
                __auto_size: null,
                __process: null,
                __move: null,

                is_rendering: false,
                autofit_has_been_triggered: false,

                init() {
                    this.__auto_size = _.debounce(this.auto_size, 1);
                    this.__process = _.debounce(this.process, 1);
                    this.__move = _.debounce(this.move, 1);

                    // Add listeners
                    this.$el.addEventListener("keydown", e => this.keydown(e.key) && e.preventDefault(), false);

                    ["zome", "labels", "axes", "vanishing_lines"].forEach(
                        (key) => this.$watch(`draw_${key}`, (value) => {
                            this.set_visibility(key, value);
                        })
                    );

                    this.num_spirals_to_display = this.params.num_spirals;
                    this.last_num_spirals = this.params.num_spirals;

                    ["num_spirals_to_display", "add_zome_reflection", "inverse_Y_Z_axes", "add_floor", "type_of_3D_objects"].forEach(
                        (key) => this.$watch(key, () => {
                            this.__process();
                        })
                    );

                    // Screenfull lister
                    if (this.can_use_screenfull) {
                        screenfull.on('change', () => {
                            this.is_fullscreen = screenfull.isFullscreen;
                            this.__auto_size();
                        });
                    }

                    // Set Canvas Parameters
                    canvas_container = this.$refs.canvas_container_3D;
                    const [width, height] = [canvas_container.offsetWidth, canvas_container.offsetHeight]

                    // Renderer canvas
                    renderer = new THREE.WebGLRenderer({
                        alpha: true,
                        antialias: true,
                        preserveDrawingBuffer: true,
                    });
                    canvas = renderer.domElement
                    canvas_container.appendChild(canvas);

                    // Scene
                    scene = new THREE.Scene();

                    // Add lights
                    const ambient_light = new THREE.AmbientLight(0xffffff, 0.9);
                    scene.add(ambient_light);

                    const directional_light = new THREE.DirectionalLight(0xffffff, 0.2);
                    directional_light.position.set(0, WORLD_HEIGHT, WORLD_HEIGHT);
                    scene.add(directional_light);

                    const directional_light2 = new THREE.DirectionalLight(0xffffff, 0.2);
                    directional_light2.position.set(0, -WORLD_HEIGHT, -WORLD_HEIGHT);
                    scene.add(directional_light2);

                    // Camera ( x is red, y is green, z is blue)
                    const [field_of_view, aspect_ratio, near, far] = [75, width / height, 0.1, 10 * WORLD_HEIGHT]
                    camera = new THREE.PerspectiveCamera(field_of_view, aspect_ratio, near, far);
                    camera.position.copy(this.home);

                    // Add controls
                    controls = new THREE.OrbitControls(camera, renderer.domElement);

                    // Add a limit to avoid that the zome disappears when you scroll too far
                    controls.maxDistance = 15000;

                    // Add (x, y, z) Axes
                    meshes.axes = new THREE.AxesHelper(WORLD_HEIGHT);
                    meshes.axes.visible = this.draw_axes;

                    scene.add(meshes.axes);

                    this.__move(this.home);
                    this.auto_size()
                    this.animate()

                    // Add listeners
                    const self = this;

                    // Use font loader to print 3D labels
                    const loader = new THREE.FontLoader();
                    loader.load('webfonts/roboto_black.typeface.json', function (loaded_font) {
                        font = loaded_font;
                        self.is_rendering = true;
                        self.$dispatch('zome-renderer-is-ready');
                    });
                },

                get clone_and_rotate_items() {
                    return !this.items_are_grouped;
                },

                get items_are_grouped() {
                    return this.type_of_3D_objects.includes("grouped_by")
                },

                capture() {
                    if (!canvas) return;

                    // here is the most important part because if you dont replace you will get a DOM 18 exception.
                    const img_url = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
                    const filename = this.gen_filename(`_${this.type_of_3D_objects}_3D_view.png`);
                    download(filename, img_url);
                },
                auto_size() {
                    const [width, height] = [canvas_container.offsetWidth, canvas_container.offsetHeight]
                    if (width > 0 && height > 0) {
                        camera.aspect = width / height;
                        camera.updateProjectionMatrix();
                        renderer.setSize(width, height);
                    }
                },
                toggle_fullscreen() {
                    if (this.can_use_screenfull) {
                        screenfull.toggle(this.$refs.rendering_container_3D);
                    }
                },
                download_ply() {
                    this.export_to(THREE.PLYExporter, "ply");
                },
                download_stl() {
                    this.export_to(THREE.STLExporter, "stl");
                },
                download_obj() {
                    const exporter = new THREE.OBJExporter();
                    const obj_to_export = this.compute_obj_to_export();

                    if (this.parts_are_separated_for_export === true) {
                        const obj_list_to_exports = [
                            ...obj_to_export.children[0].children,
                            ...obj_to_export.children[1].children
                        ];

                        const zip = new JSZip();
                        const num_children = obj_list_to_exports.length;
                        for (let i = 0; i < num_children; i++) {
                            const obj_name = obj_list_to_exports[i].name
                            const obj_filename = `${obj_name}.obj`;
                            const mtl_filename = `${obj_name}.mtl`;

                            const data = exporter.parse(obj_list_to_exports[i], mtl_filename);
                            const obj_blob = new Blob([data.obj], {type: 'text/plain'});
                            const mtl_blob = new Blob([data.mtl], {type: 'text/plain'});

                            zip.file(obj_filename, obj_blob);
                            zip.file(mtl_filename, mtl_blob);
                        }

                        const filename = this.gen_filename(`_${this.type_of_3D_objects}_obj_parts.zip`);
                        zip.generateAsync({type: "blob"}).then(function (content) {
                            save_as(content, filename);
                        });
                    } else {
                        const filename = this.gen_filename(`_${this.type_of_3D_objects}`);
                        const obj_filename = `${filename}.obj`;
                        const mtl_filename = `${filename}.mtl`;

                        const data = exporter.parse(obj_to_export, mtl_filename);
                        const obj_blob = new Blob([data.obj], {type: 'text/plain'});
                        const mtl_blob = new Blob([data.mtl], {type: 'text/plain'});

                        const zip = new JSZip();
                        zip.file(obj_filename, obj_blob);
                        zip.file(mtl_filename, mtl_blob);

                        zip.generateAsync({type: "blob"}).then(function (content) {
                            save_as(content, `${filename}_obj.zip`);
                        });
                    }

                },
                download_gltf() {
                    const exporter = new THREE.GLTFExporter();

                    // Because GLTF is in meters, convert millimeters to meters
                    const obj_to_export = this.compute_obj_to_export();
                    obj_to_export.scale.set(0.001, 0.001, 0.001);

                    exporter.parse(
                        obj_to_export,
                        (res) => {
                            const str = JSON.stringify(res, null, 2);
                            const blob = new Blob([str], {type: 'text/plain'});

                            const filename = this.gen_filename(`_${this.type_of_3D_objects}.gltf`);
                            download(filename, URL.createObjectURL(blob));
                        },
                        (error) => console.error(error),
                        {binary: false},
                    );
                },
                export_to(cls, ext) {
                    const exporter = new cls();
                    const obj_to_export = this.compute_obj_to_export();

                    if (this.parts_are_separated_for_export === true) {
                        const obj_list_to_exports = [
                            ...obj_to_export.children[0].children,
                            ...obj_to_export.children[1].children
                        ];

                        const zip = new JSZip();
                        const num_children = obj_list_to_exports.length;
                        for (let i = 0; i < num_children; i++) {
                            const str = exporter.parse(obj_list_to_exports[i]);
                            const mesh_blob = new Blob([str], {type: 'text/plain'});

                            const obj_name = obj_list_to_exports[i].name
                            const mesh_filename = `${obj_name}.${ext}`;

                            zip.file(mesh_filename, mesh_blob);
                        }

                        const filename = this.gen_filename(`_${this.type_of_3D_objects}_${ext}_parts.zip`);
                        zip.generateAsync({type: "blob"}).then(function (content) {
                            save_as(content, filename);
                        });
                    } else {
                        const str = exporter.parse(obj_to_export);
                        const blob = new Blob([str], {type: 'text/plain'});

                        const filename = this.gen_filename(`_${this.type_of_3D_objects}.${ext}`);
                        save_as(blob, filename);
                    }
                },
                get openscad_content(){
                    let output_str = "";
                    // Build 3D faces and edges
                    const export_name = this.gen_filename(`_${this.type_of_3D_objects}`);
                    output_str += `// File: ${export_name}\n`;


                    return output_str;
                },
                compute_obj_to_export() {
                    // Build 3D faces and edges
                    const obj_to_export = new THREE.Group();
                    obj_to_export.name = this.gen_filename(`_${this.type_of_3D_objects}`);

                    const zome_meshes = new THREE.Group();
                    zome_meshes.name = "Zome";

                    const label_meshes = new THREE.Group();
                    label_meshes.name = "Labels";

                    function add_to_group(group, mesh){
                        const mesh_uuid = mesh.uuid.replaceAll("-", "");
                        mesh.traverse(o => {
                            o.name = `${o.name}_${mesh_uuid}`;
                        });
                        group.add(mesh);
                    }

                    if (this.items_are_grouped) {
                        const groups = eval(`ZOME.${this.type_of_3D_objects}`);
                        let z_origin = 0;
                        _.forIn(groups, group => {
                            const item = group.item.put_on_the_ground();

                            // Compute a translation vec to align and spread items
                            const translation_vec = [-item.x_min, -item.y_min, -item.z_min + z_origin];

                            // Apply translation vector
                            add_to_group(zome_meshes, clone_3D_obj(item.mesh, translation_vec))

                            // Add Label
                            if (this.draw_labels) {
                                item.compute_label_mesh(font);
                                if (item.label_mesh) {
                                    add_to_group(label_meshes, clone_3D_obj(item.label_mesh, translation_vec))
                                }
                            }

                            // Increase origin on Z axis
                            z_origin += item.depth + 50;
                        });
                    } else {
                        const items_3D = eval(`ZOME.${this.type_of_3D_objects}`);

                        // Same as above but for spirals with geometry cloning for more efficiency
                        for (let i = 0; i < items_3D.length; i++) {
                            const item = items_3D[i];

                            if (this.draw_labels) {
                                item.compute_label_mesh(font);
                                if (item.label_mesh) {
                                    add_to_group(label_meshes, clone_3D_obj(item.label_mesh));
                                }
                            }

                            for (let spiral_index = 0; spiral_index < ZOME.num_spirals; spiral_index++) {
                                const rotation_angle = ZOME.rotation_angles[spiral_index].rad;

                                if (spiral_index < this.num_spirals_to_display) {
                                    const rotated_mesh = clone_3D_obj(item.mesh);
                                    rotated_mesh.rotateY(rotation_angle);
                                    add_to_group(zome_meshes, rotated_mesh);
                                }
                            }
                        }
                    }

                    const delta_y = (this.clone_and_rotate_items) ? ZOME.y_min : 0;

                    // Add Zome reflection
                    if (this.clone_and_rotate_items && this.add_zome_reflection) {
                        const mirror_vec = new THREE.Vector3(1, -1, 1);
                        const num_children = zome_meshes.children.length;
                        for (let i = 0; i < num_children; i++) {
                            const reflected_mesh = clone_3D_obj(zome_meshes.children[i]);
                            reflected_mesh.scale.multiply(mirror_vec);
                            reflected_mesh.translateY(2 * delta_y);
                            add_to_group(zome_meshes, reflected_mesh);
                        }
                    }

                    let floor_3D = this.get_floor_3D();
                    if (this.add_floor && floor_3D != null && floor_3D.mesh != null) {
                        add_to_group(zome_meshes, clone_3D_obj(floor_3D.mesh));
                    }
                    obj_to_export.add(zome_meshes);
                    obj_to_export.add(label_meshes);

                    // Inverse Y and Z axes
                    if (this.inverse_Y_Z_axes) {
                        obj_to_export.translateZ(-delta_y)
                        obj_to_export.rotateX(TAU_Q);
                        obj_to_export.rotateY(-TAU_Q);
                    } else {
                        obj_to_export.translateY(-delta_y)
                    }
                    obj_to_export.updateMatrixWorld(true);
                    return obj_to_export;
                },

                clear() {
                    // Create and clean old old meshes
                    if (meshes.vanishing_lines instanceof THREE.Group) {
                        scene.remove(meshes.vanishing_lines)
                    }
                    meshes.vanishing_lines = new THREE.Group();

                    if (meshes.zome instanceof THREE.Group) {
                        scene.remove(meshes.zome)
                    }
                    meshes.zome = new THREE.Group();

                    if (meshes.edges instanceof THREE.Group) {
                        scene.remove(meshes.edges)
                    }
                    meshes.edges = new THREE.Group();

                    if (meshes.labels instanceof THREE.Group) {
                        scene.remove(meshes.labels)
                    }
                    meshes.labels = new THREE.Group();
                },

                process() {
                    this.clear();

                    if (this.last_num_spirals !== ZOME.num_spirals) {
                        this.num_spirals_to_display = this.last_num_spirals = ZOME.num_spirals;
                    }
                    // Display switch buttons
                    this.show_vanishing_lines_toggle_btn = ZOME.vanishing_lines
                        && ZOME.vanishing_lines.length > 0
                        && this.type_of_3D_objects === "skeleton";

                    // Display vanishing lines
                    {
                        _.forEach(ZOME.vanishing_lines, (line) => {
                            const points = [new THREE.Vector3(...line[0]), new THREE.Vector3(...line[1])];
                            meshes.vanishing_lines.add(
                                new THREE.Line(
                                    new THREE.BufferGeometry().setFromPoints(points),
                                    THREE_VANISHING_LINES_MATERIAL
                                )
                            )
                        });
                        scene.add(meshes.vanishing_lines);
                        this.set_visibility("vanishing_lines", this.show_vanishing_lines_toggle_btn && this.draw_vanishing_lines);
                    }

                    // Build 3D faces and edges
                    const mesh_points = [], mesh_colors = [], edge_points = [];

                    if (this.items_are_grouped) {
                        const groups = eval(`ZOME.${this.type_of_3D_objects}`);
                        let z_origin = 0;
                        _.forIn(groups, group => {
                            const item = group.item.put_on_the_ground();

                            // Compute a translation vec to align and spread items
                            const translation_vec = [-item.x_min, -item.y_min, -item.z_min + z_origin];

                            // Apply translation vector
                            mesh_points.push(...item.mesh_points.map(v => new THREE.Vector3(...add(v.toArray(), translation_vec))));
                            edge_points.push(...item.edge_points.map(v => new THREE.Vector3(...add(v.toArray(), translation_vec))));

                            // Add colors
                            mesh_colors.push(...item.mesh_colors);

                            // Add Label
                            item.compute_label_mesh(font);
                            if (item.label_mesh) {
                                meshes.labels.add(
                                    clone_3D_obj(item.label_mesh, translation_vec)
                                );
                            }

                            // Increase origin on Z axis
                            z_origin += item.depth + 50;
                        });
                    } else {
                        const items_3D = eval(`ZOME.${this.type_of_3D_objects}`);
                        for (let i = 0; i < items_3D.length; i++) {
                            const item = items_3D[i];
                            mesh_points.push(...item.mesh_points);
                            mesh_colors.push(...item.mesh_colors);
                            edge_points.push(...item.edge_points);

                            item.compute_label_mesh(font);
                            if (item.label_mesh) meshes.labels.add(item.label_mesh);
                        }
                    }

                    // Build mesh and edge geometries
                    const mesh_geometry = new THREE.BufferGeometry().setFromPoints(mesh_points);
                    mesh_geometry.setAttribute('color', new THREE.Float32BufferAttribute(mesh_colors, 3));
                    mesh_geometry.computeVertexNormals()
                    let mesh = new THREE.Mesh(mesh_geometry, THREE_VERTEX_COLOR_MATERIAL);
                    const item_type = this.clone_and_rotate_items ? 'Spiral' : 'Item';
                    mesh.name = `${item_type} 1`;
                    meshes.zome.add(mesh)

                    const edge_geometry = new THREE.BufferGeometry().setFromPoints(edge_points);
                    const edges = new THREE.LineSegments(edge_geometry, THREE_EDGES_MATERIAL);
                    meshes.edges.add(edges);

                    // Clone meshes and rotate them around Y Axes
                    if (this.clone_and_rotate_items) {
                        for (let spiral_index = 1; spiral_index < ZOME.num_spirals; spiral_index++) {
                            const angle = ZOME.rotation_angles[spiral_index].rad;

                            // Add mesh
                            if (spiral_index < this.num_spirals_to_display) {
                                const rotated_mesh_geometry = mesh_geometry.clone();
                                rotated_mesh_geometry.rotateY(angle);

                                const rotated_mesh = new THREE.Mesh(rotated_mesh_geometry, THREE_VERTEX_COLOR_MATERIAL);
                                rotated_mesh.name = `${item_type} ${spiral_index + 1}`;
                                meshes.zome.add(rotated_mesh)
                            }

                            // Add edges
                            const rotated_edge_geometry = edge_geometry.clone()
                            rotated_edge_geometry.rotateY(angle);

                            const rotated_edges = new THREE.LineSegments(rotated_edge_geometry, THREE_EDGES_MATERIAL);
                            meshes.edges.add(rotated_edges);
                        }
                    }

                    const delta_y = (this.clone_and_rotate_items) ? ZOME.y_min : 0;

                    // Add zome reflection
                    if (this.clone_and_rotate_items && this.add_zome_reflection) {
                        const mirror_vec = new THREE.Vector3(1, -1, 1);
                        _.forEach(meshes, (mesh, name) => {
                            // Don't clone axes
                            if (["axes", "vanishing_lines", "labels"].includes(name)) return;

                            const cloned_mesh = clone_3D_obj(mesh);
                            cloned_mesh.scale.multiply(mirror_vec);
                            cloned_mesh.translateY(2 * delta_y)
                            mesh.add(cloned_mesh);
                        });
                    }

                    // Add floor
                    let floor_3D = this.get_floor_3D()
                    this.show_add_floor_btn = floor_3D != null;
                    if (this.add_floor && this.show_add_floor_btn && floor_3D.mesh != null) {
                        if (this.draw_zome) meshes.zome.add(floor_3D.mesh);
                        meshes.edges.add(floor_3D.edges);
                    }

                    // Inverse Y and Z axes
                    _.forEach(meshes, (mesh, name) => {
                        // Don't rotate axes
                        if (name === "axes") return;
                        if (this.inverse_Y_Z_axes) {
                            mesh.translateZ(-delta_y)
                            mesh.rotateX(TAU_Q);
                            mesh.rotateY(-TAU_Q);
                        } else {
                            mesh.translateY(-delta_y)
                        }
                    });

                    // Add the final obj mesh to the scene
                    scene.add(meshes.zome);
                    this.set_visibility("zome", this.draw_zome);

                    scene.add(meshes.edges);
                    scene.add(meshes.labels);
                    this.set_visibility("labels", this.draw_labels);

                    if (!this.autofit_has_been_triggered) {
                        this.autofit_has_been_triggered = true;
                        this.move(this.home);
                    }
                },

                get_floor_3D() {
                    switch (this.type_of_3D_objects) {
                        case "inner_faces":
                        case "skeleton":
                            return ZOME.inner_floor;
                        case "outer_faces":
                            return ZOME.outer_floor;
                    }
                    return null
                },
                get bounding_box() {
                    // Get bounding box of zome - this will be used to setup controls and camera
                    let bounding_box = null;
                    if (meshes.zome instanceof THREE.Group) {
                        bounding_box = new THREE.Box3();
                        bounding_box.setFromObject(meshes.zome);
                    }
                    return bounding_box;
                },
                get zome_size() {
                    return (this.bounding_box instanceof THREE.Box3)
                        ? this.bounding_box.getSize()
                        : new THREE.Vector3(WORLD_HEIGHT, WORLD_HEIGHT, WORLD_HEIGHT);
                },
                get zome_height() {
                    return this.zome_size.y;
                },
                get right() {
                    return new THREE.Vector3(this.zome_height * 1.5, this.zome_height * 0.5, 0);
                },
                get left() {
                    return new THREE.Vector3(0, this.zome_height * 0.5, this.zome_height * 1.5);
                },
                get down() {
                    return new THREE.Vector3(0, -this.zome_height * 2, 0);
                },
                get up() {
                    return new THREE.Vector3(0, this.zome_height * 2, 0);
                },
                get home() {
                    return new THREE.Vector3(this.zome_height * 1.05, this.zome_height * 0.5, this.zome_height * 1.05);
                },
                move(v) {
                    controls.reset();
                    controls.target.set(0, this.zome_height / 2.5, 0);
                    camera.position.copy(v);
                    controls.update();
                },
                set_visibility(key, value) {
                    if (meshes.hasOwnProperty(key) && meshes[key].hasOwnProperty("visible")) {
                        meshes[key].visible = value
                    }
                },
                update() {
                    if (this.is_spinning) {
                        scene.rotation.y -= this.speed;
                    }
                },
                render() {
                    if (this.is_rendering) {
                        renderer.render(scene, camera)
                    }
                },
                animate() {
                    this.update()
                    requestAnimationFrame(() => this.animate());
                    this.render()
                },
                increase_speed() {
                    this.speed += 0.001;
                },
                decrease_speed() {
                    this.speed -= 0.001;
                },
                keydown(key) {
                    switch (key) {
                        case "*":
                            this.increase_speed()
                            break;
                        case "/":
                            this.decrease_speed()
                            break;
                        case " ":
                            this.is_spinning = !this.is_spinning;
                            break;
                        case "c":
                        case "C":
                            this.type_of_3D_objects = "timbers_grouped_by_face";
                            break;
                        case "o":
                        case "O":
                            this.type_of_3D_objects = "outer_faces";
                            break;
                        case "i":
                        case "I":
                            this.type_of_3D_objects = "inner_faces";
                            break;
                        case "h":
                        case "H":
                            this.move(this.home);
                            break;
                        case "l":
                        case "L":
                            this.type_of_3D_objects = "outer_faces_grouped_by_hash";
                            break;
                        case "k":
                        case "K":
                            this.type_of_3D_objects = "inner_faces_grouped_by_hash";
                            break;
                        case "m":
                        case "M":
                        case "f":
                        case "F":
                            this.type_of_3D_objects = "flattened_faces";
                            break;
                        case "t":
                        case "T":
                            this.type_of_3D_objects = "timber_profiles_grouped_by_hash";
                            break;
                        case "s":
                        case "S":
                        case "s":
                        case "Z":
                            this.type_of_3D_objects = "skeleton";
                            break;
                        case "Down":
                        case "ArrowDown":
                            this.move(this.down);
                            break;
                        case "Up":
                        case "ArrowUp":
                            this.move(this.up);
                            break;
                        case "Left":
                        case "ArrowLeft":
                            this.move(this.left);
                            break;
                        case "Right":
                        case "ArrowRight":
                            this.move(this.right);
                            break;
                        case "Escape":
                            if(this.openscad_panel_is_hidden) return false;

                            this.openscad_panel_is_hidden = !this.openscad_panel_is_hidden;
                            break;
                        default:
                            return false;
                    }
                    return true
                },
            };
        });

        Alpine.data('settings', () => {
            return {
                // Group parameters
                params: {
                    // Shape Parameters
                    num_spirals: 10,                    // number of spirals
                    theta_deg: 52,                      // In degrees, angle of shape which allows to calculate the slope of the first rhombus.
                    angle_unit: "deg",                  // Degrees or Radians

                    use_hr_mode: false,
                    height_ratio: 0.6,                  // Height ratio as proportion of pole-to-pole distance (0.5 => middle)
                    kite_ratio: 1,                      // Kite ratio, lower half to upper half (1 => is rhombus else kites)

                    // Framework Parameters
                    measuring_unit: "cm",                               // Measuring unit by default is cm
                    zome_height_in_mm: WORLD_HEIGHT,    // Height in mm
                    timber_width_in_mm: 80,                             // Timber width in mm
                    timber_thickness_in_mm: 60,                         // Timber thickness in mm
                    z_vanishing_point_in_mm: null,
                    assembly_method: 1,
                    assembly_direction: 0,
                    xpansion_direction: 1,
                    add_footing: 1,

                    // Roof parameters
                    roof_overflow_in_mm: 0,

                    // Values separated by commas
                    face_divisions_by_crowns_str: "",
                    bindu_ratios_str: "",

                    // Commons parameters, Not Zome params, but we save them
                    language: null,
                    help_is_displayed: false,
                },
                params_backup: null,

                // Height Ratio properties
                suggested_height_ratio: null,       // Value to magnetize zome to the nearest cut

                // Selected Crown properties
                num_crowns: 1,
                selected_crown: 1,
                face_divisions_by_crowns: [],
                num_points_per_crown: [],
                selected_face_divisions_bitwise_flag: 0,
                num_points_of_selected_crown: 4,
                crown_of_framework_timbers_is_valid: true,
                selected_bindu_ratio: 1,

                // Common properties
                show_splash_screen: true,
                is_computing: true,
                framework_is_machinable: true,

                colors: [],
                i18n_dictionary: {},

                // Debouncers
                __make_zome: null,

                async init() {
                    this.__make_zome = _.debounce(this.make_zome, 1);

                    // Dynamic default params
                    this.params.z_vanishing_point_in_mm = this.zome_centroid;

                    // Update translated texts
                    this.$watch(`i18n_dictionary`, () => {
                        // remove old tooltips
                        const old_tooltips = document.getElementsByClassName('tooltip');
                        if (old_tooltips) {
                            _.map(old_tooltips, (e) => e.remove());
                        }

                        const tooltip_trigger_elements = document.querySelectorAll('[data-bs-toggle="tooltip"]')
                        const new_tooltips = [...tooltip_trigger_elements].map((el) => {
                            return new bootstrap.Tooltip(el, {
                                placement: "bottom",
                                trigger: "hover",
                            });
                        });
                    });

                    // Change language listener
                    this.$watch(`params.language`, () => {
                        this.set_language(this.params.language);
                    });

                    // Init params
                    this.params = sync_params_from_url(this.params);
                    if (!this.params.language) {
                        this.params.language = I18_DEFAULT_LANGUAGE;
                    }
                    this.params.assembly_direction = this.constrained_assembly_direction;
                    this.save_params(false);

                    // Add shape parameter listeners
                    const zome_param_keys = Object.keys(this.params);
                    _.forEach(zome_param_keys, key => {
                        this.$watch(`params.${key}`, (value) => {
                            this.clamp(key, value);
                            this.__make_zome();
                        });
                    });

                    this.$watch("max_timber_width", () => {
                        this.clamp("timber_width_in_mm", this.params.timber_width_in_mm);
                    });

                    this.$watch("max_timber_thickness", () => {
                        this.clamp("timber_thickness_in_mm", this.params.timber_thickness_in_mm);
                    });

                    // Constrains the assembly direction depending on assembly method
                    this.$watch("params.assembly_method", () => {
                        this.params.assembly_direction = this.constrained_assembly_direction;
                    });

                    // Refresh the height_ratio if you change the zome params.num_spirals
                    _.forEach(["num_spirals", "use_hr_mode"], key => {
                        this.$watch(`params.${key}`, (value) => {
                            this.clamp("height_ratio", this.params.height_ratio);
                            if (!this.params.use_hr_mode) {
                                this.params.kite_ratio = 1;
                                this.params.height_ratio = to_decimal((this.num_rhombuses_vertically + 1) / this.params.num_spirals);
                            }
                        });
                    });

                    // Selected crown listener
                    _.forEach(["num_crowns", "params.height_ratio", "params.face_divisions_by_crowns_str"], key => {
                        this.$watch(key, (value) => {
                            this.init_face_divisions();
                            this.update_face_divisions();
                            this.init_bindu_ratios();
                            this.update_bindu_ratio();
                        });
                    });

                    this.$watch("selected_face_divisions_bitwise_flag", (value) => {
                        const bitwise_flags = str_to_numbers(this.params.face_divisions_by_crowns_str);
                        bitwise_flags[this.selected_crown - 1] = value;
                        this.params.face_divisions_by_crowns_str = numbers_2_str(bitwise_flags);
                    });

                    // Clamp selected_crown value
                    this.$watch("selected_crown", () => {
                        this.update_face_divisions();
                        this.update_bindu_ratio();
                    });

                    this.$watch("selected_bindu_ratio", () => {
                        this.clamp("selected_bindu_ratio", this.selected_bindu_ratio, false);
                        this.update_bindu_ratios();
                    });

                    this.$watch("face_divisions_by_crowns", (value) => {
                        this.crown_of_framework_timbers_is_valid = this.is_crown_of_framework_timbers_valid(
                            this.face_divisions_by_crowns[this.selected_crown - 1]
                        );

                        // Save param only if crown of framework is valid
                        if (this.crown_of_framework_timbers_is_valid) {
                            this.params.face_divisions_by_crowns_str = numbers_2_str(
                                boolean_matrix_to_bitwise_flags(this.face_divisions_by_crowns)
                            );
                        }

                    });


                    // Refresh data related to the height
                    // if you change the zome height
                    this.$watch("params.zome_height_in_mm", () => {
                        this.clamp("z_vanishing_point_in_mm", this.z_vanishing_point_in_mm);
                    });

                    _.forEach(["height_ratio", "zome_height_in_mm"], key => {
                        this.$watch(`params.${key}`, () => {
                            this.clamp("z_vanishing_point_in_mm", this.zome_centroid);
                        });
                    });

                    // Use ClipboardJS to copy URL
                    const clipboard = new ClipboardJS("#copy-url-btn", {
                        text: function () {
                            return document.location.href;
                        }
                    });

                    const self = this;
                    clipboard.on('success', function () {
                        self.show_toast(self.i18n('toast_link_copied'), "link");
                    });
                    clipboard.on('error', function () {
                        self.show_error();
                    });
                },
                set_language(lng) {
                    // verify that the language exists
                    const new_lng = (I18N_LANGUAGES.hasOwnProperty(this.params.language) && I18N_LANGUAGES[this.params.language].hasOwnProperty("dictionary"))
                        ? lng
                        : I18_DEFAULT_LANGUAGE;

                    // Get dictionary to apply new language
                    this.i18n_dictionary = I18N_LANGUAGES[new_lng].dictionary;

                    // Save params to url
                    sync_url_from_params(this.params)
                },
                init_face_divisions() {
                    // Get current face_divisions and fill missing values
                    const current_numbers = str_to_numbers(this.params.face_divisions_by_crowns_str);
                    const numbers = new Array(this.num_crowns);
                    for (let i = 0; i < this.num_crowns; i++) {
                        numbers[i] = current_numbers[i] || 0;
                    }
                    this.params.face_divisions_by_crowns_str = numbers_2_str(numbers);
                },
                update_face_divisions() {
                    this.clamp("selected_crown", this.selected_crown, false);
                    const bitwise_flags = str_to_numbers(this.params.face_divisions_by_crowns_str);
                    this.face_divisions_by_crowns = bitwise_flags_to_boolean_matrix(bitwise_flags);
                    this.selected_face_divisions_bitwise_flag = bitwise_flags[this.selected_crown - 1] || 0;
                    this.num_points_of_selected_crown = this.num_points_per_crown[this.selected_crown - 1] || 4;
                },
                get can_use_bindu_ratio() {
                    return this.num_points_of_selected_crown !== 3
                        && [SVG_HORIZONTAL_BAR_BITWISE_FLAG, SVG_VERTICAL_BAR_BITWISE_FLAG].includes(
                            this.selected_face_divisions_bitwise_flag
                        );
                },
                init_bindu_ratios() {
                    const face_divisions_by_crowns = str_to_numbers(this.params.face_divisions_by_crowns_str);
                    const current_bindu_ratios = str_to_numbers(this.params.bindu_ratios_str);
                    const bindu_ratios = new Array(this.num_crowns);
                    for (let i = 0; i < this.num_crowns; i++) {
                        const can_use_bindu_ratio = this.num_points_per_crown[i] !== 3
                            && [SVG_HORIZONTAL_BAR_BITWISE_FLAG, SVG_VERTICAL_BAR_BITWISE_FLAG].includes(
                                face_divisions_by_crowns[i]
                            );
                        bindu_ratios[i] = (can_use_bindu_ratio) ? current_bindu_ratios[i] || 1 : 1;
                    }
                    this.params.bindu_ratios_str = numbers_2_str(bindu_ratios);
                },
                update_bindu_ratio() {
                    const bindu_ratios = str_to_numbers(this.params.bindu_ratios_str);
                    this.selected_bindu_ratio = bindu_ratios[this.selected_crown - 1] || 1;
                },
                update_bindu_ratios() {
                    const bindu_ratios = str_to_numbers(this.params.bindu_ratios_str);
                    bindu_ratios[this.selected_crown - 1] = this.selected_bindu_ratio;
                    this.params.bindu_ratios_str = numbers_2_str(bindu_ratios);
                },
                is_framework_timber_selected(svg_index = 0) {
                    const framework_timber_crown = this.face_divisions_by_crowns[this.selected_crown - 1];
                    return framework_timber_crown && framework_timber_crown[svg_index];
                },
                toggle_framework_timber(svg_index) {
                    const framework_timber_crown = this.face_divisions_by_crowns[this.selected_crown - 1];
                    framework_timber_crown[svg_index] = (framework_timber_crown[svg_index]) ? false : true;
                    this.face_divisions_by_crowns[this.selected_crown - 1] = [...framework_timber_crown];
                },
                is_crown_of_framework_timbers_valid(framework_timber_crown) {
                    // Check if there is consecutive_unselected that is more and equal than 4
                    let first_selected = null,
                        last_selected = null,
                        consecutive_unselected = 0;

                    for (let svg_index = 0; svg_index < 8; svg_index++) {
                        const is_selected = framework_timber_crown && framework_timber_crown[svg_index];
                        if (is_selected) {
                            last_selected = svg_index;
                            consecutive_unselected = 0;
                            if (first_selected === null) first_selected = svg_index;
                        } else if (first_selected !== null) {
                            consecutive_unselected++;
                            if (consecutive_unselected >= 4) {
                                return false;
                            }
                        }
                    }

                    if (last_selected != null && first_selected != null) {
                        const consecutive_unselected = (first_selected + 7 - last_selected);
                        if (consecutive_unselected >= 4) {
                            return false;
                        }
                    }

                    // The crown is valid
                    return true;
                },
                set_face_divisions(crown_index, value) {
                    // this.face_divisions_by_crowns
                },
                i18n(key, value = null) {
                    // Translation function using JSON dictionnaries
                    // Return the key if not found in language and default language dictionaries
                    let translated_txt = key;

                    if (this.i18n_dictionary.hasOwnProperty(key)) {
                        translated_txt = this.i18n_dictionary[key];
                    } else if (this.i18n_default_dictionary.hasOwnProperty(key)) {
                        translated_txt = this.i18n_default_dictionary[key];
                    } else {
                        console.warn(`Translation '${key}' not founded !`);
                    }

                    if (value) {
                        translated_txt = translated_txt.replaceAll('$1', value);
                    }

                    return translated_txt;
                },
                get i18n_default_dictionary() {
                    if (!(I18N_LANGUAGES.hasOwnProperty(I18_DEFAULT_LANGUAGE)
                        && I18N_LANGUAGES[I18_DEFAULT_LANGUAGE].hasOwnProperty("dictionary")
                    )) {
                        console.error(`This language '${I18_DEFAULT_LANGUAGE}' is not available`)
                        return;
                    }

                    return I18N_LANGUAGES[I18_DEFAULT_LANGUAGE].dictionary;
                },
                show_error() {
                    self.show_toast(this.i18n('toast_error'), "triangle-exclamation", true);
                },
                get theta() {
                    switch (this.params.angle_unit) {
                        case "rad":
                            return to_decimal(deg2rad(this.params.theta_deg));
                        case "tan":
                            return to_decimal(Math.tan(deg2rad(this.params.theta_deg)));
                        case "deg":
                        default:
                            return this.params.theta_deg;
                    }
                },
                set theta(angle) {
                    switch (this.params.angle_unit) {
                        case "rad":
                            this.params.theta_deg = rad2deg(angle)
                            break;
                        case "tan":
                            this.params.theta_deg = rad2deg(Math.atan(angle))
                            break;
                        case "deg":
                        default:
                            this.params.theta_deg = angle;
                    }
                },
                get num_rhombuses_vertically() {
                    return Math.round(this.params.num_spirals * this.params.height_ratio - 1, 0);
                },
                set num_rhombuses_vertically(value) {
                    this.params.kite_ratio = 1;
                    this.params.height_ratio = to_decimal((value + 1) / this.params.num_spirals);
                },
                get is_rhombus() {
                    return this.params.kite_ratio === 1;
                },
                set is_rhombus(value) {
                    if (value === true) {
                        this.params.kite_ratio = 1
                    }
                },
                get zome_height() {
                    return to_decimal(from_mm(this.params.zome_height_in_mm, this.params.measuring_unit));
                },
                set zome_height(value) {
                    this.clamp("zome_height_in_mm", to_mm(value, this.params.measuring_unit));
                },
                get timber_width() {
                    return to_decimal(from_mm(this.params.timber_width_in_mm, this.params.measuring_unit));
                },
                set timber_width(value) {
                    this.clamp("timber_width_in_mm", to_mm(value, this.params.measuring_unit));
                },
                get roof_overflow() {
                    return to_decimal(from_mm(this.params.roof_overflow_in_mm, this.params.measuring_unit));
                },
                set roof_overflow(value) {
                    this.clamp("roof_overflow_in_mm", to_mm(value, this.params.measuring_unit));
                },
                get max_timber_width() {
                    return to_decimal(this.first_crown_radius / 2, FLOAT_2_STR_PRECISION);
                },
                get timber_thickness() {
                    return to_decimal(from_mm(this.params.timber_thickness_in_mm, this.params.measuring_unit));
                },
                set timber_thickness(value) {
                    this.clamp("timber_thickness_in_mm", to_mm(value, this.params.measuring_unit));
                },
                get max_timber_thickness() {
                    return to_decimal(this.first_crown_radius * Math.sin(Math.PI / (this.params.num_spirals)));
                },
                set z_vanishing_point(value) {
                    this.clamp("z_vanishing_point_in_mm", to_mm(value, this.params.measuring_unit));
                },
                get z_vanishing_point() {
                    return to_decimal(from_mm(this.params.z_vanishing_point_in_mm, this.params.measuring_unit));
                },
                get zome_centroid() {
                    // vertical center of entire zome
                    return this.params.zome_height_in_mm - this.zome_total_height_in_mm / 2;
                },
                get min_z_vanishing_point() {
                    return this.params.zome_height_in_mm - this.zome_total_height_in_mm * 0.95;
                },
                get max_z_vanishing_point() {
                    return this.params.zome_height_in_mm - this.zome_total_height_in_mm * 0.05;
                },
                get is_vanishing_centered() {
                    return to_decimal(this.params.z_vanishing_point_in_mm) === to_decimal(this.zome_centroid);
                },
                set is_vanishing_centered(value) {
                    if (value === true) {
                        this.params.z_vanishing_point_in_mm = this.zome_centroid;
                    }
                },
                get zome_total_height_in_mm() {
                    return this.params.zome_height_in_mm / this.params.height_ratio;
                },
                get k_sum() {
                    return this.is_rhombus ? this.params.num_spirals : (1 - Math.pow(this.params.kite_ratio, this.params.num_spirals)) / (1 - this.params.kite_ratio);
                },
                // First crown properties
                get first_edge() {
                    return this.zome_total_height_in_mm / (this.k_sum * Math.cos(deg2rad(this.params.theta_deg)));
                },
                get first_crown_radius() {
                    return this.first_edge * Math.sin(deg2rad(this.params.theta_deg));
                },
                get first_crown_height() {
                    return this.first_edge * Math.cos(deg2rad(this.params.theta_deg));
                },
                get can_use_screenfull() {
                    return screenfull && screenfull.isEnabled && !IS_MOBILE;
                },
                get num_assembly_directions() {
                    return ASSEMBLY_DIRECTIONS.length;
                },
                get constrained_assembly_direction() {
                    return this.params.assembly_direction % this.num_assembly_directions;
                },
                set constrained_assembly_direction(value) {
                    this.params.assembly_direction = value % this.num_assembly_directions;
                },
                reset_params() {
                    this.params = _.cloneDeep(this.params_backup);
                    this.show_toast(this.i18n('toast_settings_restored'), "rotate")
                },
                save_params(toast = true) {
                    this.params_backup = _.cloneDeep(this.params);
                    if (toast) {
                        this.show_toast(this.i18n('toast_settings_save'), "floppy-disk")
                    }
                },
                show_toast(txt, icon = null, error = false) {
                    // Update toast message and display it
                    const toast_msg = document.getElementById('toast_msg')
                    const txt_class = (error) ? "text-danger" : "text-primary";
                    let msg = (icon)
                        ? '<i class="fa-solid fa-' + icon + ' ' + txt_class + ' me-2 "></i>'
                        : '<img src="img/logo_zome.svg" width="24" class="me-2" alt="Zome Logo">';
                    msg += txt;
                    toast_msg.innerHTML = msg

                    const live_toast = document.getElementById('live_toast')
                    const toast = new bootstrap.Toast(live_toast)
                    toast.show()
                },
                magnetize() {
                    if (this.suggested_height_ratio && this.suggested_height_ratio !== this.params.height_ratio) {
                        this.params.height_ratio = this.suggested_height_ratio;
                    }
                },
                format(key, value) {
                    // Format Zome parameters by pair of [key, value]
                    switch (key) {
                        case 'num_spirals':
                        case 'selected_crown':
                            return to_decimal(value, 0);
                        default:
                            return to_decimal(value);
                    }
                },
                randomize_shape() {
                    _.forEach(["num_spirals", "theta_deg", "num_rhombuses_vertically"], (key) => {
                            const slider = this.get_slider(key);
                            this.params[key] = _.random(slider.min, slider.max)
                        },
                    );
                    this.params.timber_width_in_mm = 80;
                    this.params.timber_thickness_in_mm = 60;
                    this.params.kite_ratio = 1;
                },
                get_slider(key) {
                    const slider_id = `${key}_slider`;
                    return eval(`this.$refs.${slider_id}`) || document.getElementById(slider_id);
                },
                clamp(key, value, in_params = true) {
                    const slider = this.get_slider(key);
                    if (slider) {
                        const clamped_value = this.format(key, _.clamp(value, slider.min, slider.max));
                        if (in_params) {
                            this.params[key] = clamped_value
                        } else {
                            this[key] = clamped_value;
                        }
                    }
                },
                to_suggested_height_ratio(y, WORLD_HEIGHT, polar_height) {
                    return to_decimal((WORLD_HEIGHT - y) / polar_height);
                },
                gen_filename(suffix) {
                    const date_str = new Date().toISOString()
                        .replaceAll('-', '')
                        .replaceAll('T', '_')
                        .replaceAll(':', '')
                        .slice(0, 15);
                    return `Z5omes_${date_str}_N${this.params.num_spirals}${small_hash(this.params)}${suffix}`
                },
                add_vertex(vertices, p) {
                    vertices.push(p);
                    return vertices.length - 1;
                },
                add_face(zome_faces_3D, face, face_divisions_bitwise_flags, apply_bindu_ratio = false) {
                    if (apply_bindu_ratio) {
                        // If we apply the bindu ratio, we split face in two parts
                        const face_divisions_bitwise_flag = face_divisions_bitwise_flags[zome_faces_3D.length];
                        const faces = face.split(face_divisions_bitwise_flag);
                        const horizontal_split = face_divisions_bitwise_flag === SVG_HORIZONTAL_BAR_BITWISE_FLAG;

                        faces[0].part = (horizontal_split) ? "top" : "left";
                        zome_faces_3D.push(faces[0]);

                        // The bottom face have a new label, flag the bottom part
                        faces[1].label = ALPHABET[zome_faces_3D.length];
                        faces[1].part = (horizontal_split) ? "bottom" : "right";
                        zome_faces_3D.push(faces[1]);

                        // Then we reset bitwise flags... not perfect but it's working
                        face_divisions_bitwise_flags[zome_faces_3D.length - 2] = 0;
                        face_divisions_bitwise_flags.splice(zome_faces_3D.length - 1, 0, 0);
                    } else {
                        zome_faces_3D.push(face);
                    }
                },
                make_zome() {
                    this.is_computing = true;

                    // Init arrays of 3D points
                    let vertices = [];
                    let zome_faces_3D = [];

                    // Config Parameters
                    const N = this.params.num_spirals;
                    const K = this.params.kite_ratio;
                    const ZOME_HEIGHT_BEFORE_GENERATING_TIMBERS = this.params.zome_height_in_mm;
                    const TIMBER_WIDTH = this.params.timber_width_in_mm;
                    const TIMBER_THICKNESS = this.params.timber_thickness_in_mm;

                    // Get assembly parameters
                    const ASSEMBLY_METHOD = this.params.assembly_method;
                    const ASSEMBLY_DIRECTION = this.constrained_assembly_direction;
                    const XPANSION_DIRECTION = this.params.xpansion_direction;
                    const BINDU_RATIOS = str_to_numbers(this.params.bindu_ratios_str);
                    const face_divisions_bitwise_flags = str_to_numbers(this.params.face_divisions_by_crowns_str);

                    // Constants
                    const M = N - 1;
                    const TOTAL_HEIGHT = this.zome_total_height_in_mm;

                    // First Point at the top
                    this.add_vertex(vertices, [0, ZOME_HEIGHT_BEFORE_GENERATING_TIMBERS, 0]);

                    // First crown properties
                    const first_crown_radius = this.first_crown_radius;
                    const first_crown_height = this.first_crown_height;

                    // Initialize variables
                    let fipc, ficc, k, u,
                        iB, iA, iC, iD, iE, iF,
                        A, B, C, D, E, F, G, H,
                        midpoint, bindu_point,
                        dist_to_ground, y, face, face_label;
                    let last_is_truncated = false;
                    let closest_dist_to_ground = Number.MAX_VALUE;

                    // Compute rotation angles just once
                    // And add points on first crown every 'incr_rad' from left to right
                    const INCR_RAD = TAU / N;
                    const rotation_angles = new Array(N);
                    for (let i = 0; i < N; i++) {
                        rotation_angles[i] = new Angle(i * INCR_RAD);
                        A = [
                            first_crown_radius * rotation_angles[i].sin,
                            Math.max(0, ZOME_HEIGHT_BEFORE_GENERATING_TIMBERS - first_crown_height),
                            first_crown_radius * rotation_angles[i].cos
                        ];
                        this.add_vertex(vertices, A);
                    }

                    // Loop over crowns (M = N - 1), while zome does not hit ground
                    let hit_ground = false;
                    const last_triangle_indexes = [];

                    // We use 'crown index' term only at the vertices building.
                    let crown_index = 0;
                    const num_points_per_crown = [];

                    // Loop and build vertices array
                    for (; crown_index < M && !hit_ground; crown_index++) {
                        ficc = crown_index * N + 1;                  // First Index on current crown
                        fipc = ficc - N;                             // First index on previous crown

                        // Alphabet letter distribution
                        face_label = ALPHABET[zome_faces_3D.length]

                        // On current crown, Loop over points from left to right
                        for (let spiral_index = 0; spiral_index < N; spiral_index++) {
                            k = (spiral_index + 1) % N

                            iA = (crown_index === 0) ? 0 : fipc + k;            // Index of A point          A
                            iB = ficc + spiral_index;                           // Index of B point        B ◇ C
                            iC = ficc + k;                                      // Index of C point          D

                            A = vertices[iA];
                            B = vertices[iB];
                            C = vertices[iC];
                            midpoint = get_midpoint(B, C);

                            // Compute the new point to close diamond/kite face
                            D = add(A, mul(sub(midpoint, A), 1 + K));

                            const bindu_ratio = BINDU_RATIOS[crown_index] || 1;
                            const apply_bindu_ratio = bindu_ratio !== 1;

                            // Apply the bindu ratio
                            if (apply_bindu_ratio) {
                                bindu_point = [
                                    D[0] * bindu_ratio,
                                    D[1],
                                    D[2] * bindu_ratio
                                ];
                                D = bindu_point;
                                // Keep the same edge size
                                // D = point_to(midpoint, sub(bindu_point, midpoint), dist(midpoint, D));
                            }

                            // Draw the second part of shape while D is higher than the ground
                            y = to_decimal(D[1]);

                            // Add a tolerance to Y
                            if (y + 0.001 >= 0) {
                                // Add Shape to 3D
                                iD = this.add_vertex(vertices, D);

                                // Add only the first piece
                                if (spiral_index === 0) {
                                    face = new Polygon3D([A, B, D, C], face_label, null, crown_index);
                                    this.add_face(zome_faces_3D, face, face_divisions_bitwise_flags, apply_bindu_ratio);
                                    num_points_per_crown[crown_index] = face.num_points;
                                }

                                // Close the zome => Deal with case where this crown is exactly on the ground
                                hit_ground = to_decimal(y, 2) === 0;
                                if (hit_ground) {
                                    last_triangle_indexes.push(iD, iD, iC);
                                }
                            } else {
                                // Compute the Truncated Kite
                                u = -B[1] / (D[1] - B[1]);
                                E = add(B, mul(sub(D, B), u));
                                F = add(C, mul(sub(D, C), u));

                                // Add Truncated Kite to 3D
                                iE = this.add_vertex(vertices, E);
                                iF = this.add_vertex(vertices, F);

                                // Add Truncated Kite
                                if (spiral_index === 0) {
                                    face = new Polygon3D([A, B, E, F, C], face_label, null, crown_index);
                                    this.add_face(zome_faces_3D, face, face_divisions_bitwise_flags, apply_bindu_ratio);
                                    num_points_per_crown[crown_index] = face.num_points;
                                }
                                // Add last triangles to close it after if needed
                                last_triangle_indexes.push(iE, iF, iC);
                                hit_ground = true;
                                last_is_truncated = true;
                            }
                        }

                        // Compute the suggested height ratio for magnetize button
                        dist_to_ground = Math.abs(y);
                        if (dist_to_ground < closest_dist_to_ground) {
                            closest_dist_to_ground = dist_to_ground;
                            this.suggested_height_ratio = this.to_suggested_height_ratio(y, ZOME_HEIGHT_BEFORE_GENERATING_TIMBERS, TOTAL_HEIGHT);
                        }
                    }

                    // Close The Zome
                    const num_triangles = last_triangle_indexes.length;
                    if (num_triangles > 0) {
                        A = vertices[last_triangle_indexes[2 % num_triangles]];
                        B = vertices[last_triangle_indexes[1 % num_triangles]];
                        C = vertices[last_triangle_indexes[3 % num_triangles]];

                        // Deal with case where B and C are too close, so we don't add them
                        const far_enough = to_decimal(dist(B, C), 2) !== 0;
                        if (far_enough) {
                            // Add triangle to faces
                            face_label = ALPHABET[zome_faces_3D.length]
                            face = new Polygon3D([A, B, C], face_label, null, crown_index);
                            this.add_face(zome_faces_3D, face, face_divisions_bitwise_flags);
                            num_points_per_crown[crown_index] = face.num_points;
                            crown_index++;
                        }
                    }

                    // Make difference between num_crowns (used for face divisions)
                    const num_crowns = crown_index;
                    // And num zome faces to init outer/inner faces
                    const num_zome_faces = zome_faces_3D.length

                    // Build Outer/Inner faces
                    const outer_faces = new Array(num_zome_faces),
                        inner_faces = new Array(num_zome_faces),
                        skeleton_crowns = new Array(num_zome_faces);
                    const skeleton = [], vanishing_lines = [];

                    // Compute vanishing pt
                    const vanishing_pt = [0, this.params.z_vanishing_point_in_mm, 0];

                    // Variables for Footing building
                    let lowest_vertical_position = Number.MAX_VALUE,
                        footing_params = [];

                    // Compute dihedral angles
                    for (let face_index = 0; face_index < num_zome_faces; face_index++) {
                        const face = zome_faces_3D[face_index];
                        const plane_above = (face_index > 0)
                            ? zome_faces_3D[face_index - 1].plane
                            : rotate_point_around_y_axis(face.plane, -INCR_RAD);

                        face.dihedral_angle = Math.PI - angle_between_planes(face.plane, plane_above);
                    }

                    // Loop over the faces of the framework to build timbers
                    // Divide zome faces and build framework timbers
                    const ROOF_OVERFLOW_DISTANCE = this.params.roof_overflow_in_mm;

                    for (let face_index = 0; face_index < num_zome_faces; face_index++) {
                        const face = zome_faces_3D[face_index];

                        face.compute_framework(
                            face_divisions_bitwise_flags[face_index] || 0,
                            ASSEMBLY_METHOD,
                            ASSEMBLY_DIRECTION,
                            vanishing_pt,
                            XPANSION_DIRECTION,
                            TIMBER_THICKNESS,
                            TIMBER_WIDTH,
                        );

                        // Add timbers to skeleton 3D
                        skeleton.push(...face.framework_timbers);

                        // Add vanishing lines for the GoodKarma and Beveled methods
                        if (ASSEMBLY_METHOD < 2) {
                            vanishing_lines.push([vanishing_pt, face.points[0]]);
                        }

                        const inner_face_points = face.framework_inner_points;
                        inner_faces[face_index] = Polygon3D.copy(face, inner_face_points);
                        inner_faces[face_index].dihedral_angle = face.dihedral_angle;

                        // Add roof overflow points on outer face
                        const outer_face_points = face.framework_outer_points;
                        let outer_face = Polygon3D.copy(face, outer_face_points);
                        if (face.crown_index + 2 < num_crowns   // don't use roof overflow on last crowns
                            && face.slope < TAU_Q               // if slope is superior thant TAU_Q
                            && ROOF_OVERFLOW_DISTANCE > 0       // if there is not a minimal distance
                            && !face.is_top_part                // and not on top part of divided face (bindu option)
                        ) {
                            switch (face.part) {
                                case "left": {
                                    const vertical_vec = sub(
                                        outer_face.points[2],
                                        outer_face.midpoints[outer_face.num_points - 1],
                                    );
                                    const overflow_delta = point_to([0, 0, 0], vertical_vec, ROOF_OVERFLOW_DISTANCE);
                                    const points_with_overflow = [];
                                    for (let i = 0; i < outer_face.num_points; i++) {
                                        const normal_pt = outer_face.points[i];
                                        const pt_with_overflow = add(outer_face.points[i], overflow_delta);
                                        if (i <= 1) points_with_overflow.push(normal_pt)
                                        if (i >= 1) points_with_overflow.push(pt_with_overflow)
                                    }
                                    outer_face.points = points_with_overflow;
                                }
                                    break;
                                case "right": {
                                    const vertical_vec = sub(
                                        outer_face.points[1],
                                        outer_face.midpoints[0],
                                    );
                                    const overflow_delta = point_to([0, 0, 0], vertical_vec, ROOF_OVERFLOW_DISTANCE);
                                    const points_with_overflow = [];
                                    for (let i = 0; i < outer_face.num_points; i++) {
                                        const normal_pt = outer_face.points[i];
                                        const pt_with_overflow = add(outer_face.points[i], overflow_delta);
                                        if (i < 1) points_with_overflow.push(normal_pt)
                                        if (i >= 1) points_with_overflow.push(pt_with_overflow)
                                        if (i > 1) points_with_overflow.push(normal_pt)
                                    }
                                    outer_face.points = points_with_overflow;
                                }
                                    break;
                                case "top":
                                case "bottom":
                                default: {
                                    const bottom_index = Math.floor(face.num_points / 2);
                                    const vertical_vec = sub(outer_face.points[bottom_index], outer_face.centroid)
                                    const overflow_delta = point_to([0, 0, 0], vertical_vec, ROOF_OVERFLOW_DISTANCE);
                                    const points_with_overflow = [];
                                    for (let i = 0; i < outer_face.num_points; i++) {
                                        const normal_pt = outer_face.points[i];
                                        const pt_with_overflow = add(outer_face.points[i], overflow_delta);
                                        if (i < bottom_index) points_with_overflow.push(normal_pt);
                                        if (!(i === 0 && face.num_points === 4)) points_with_overflow.push(pt_with_overflow);
                                        if (i > bottom_index) points_with_overflow.push(normal_pt);
                                    }
                                    outer_face.points = points_with_overflow;
                                }
                                    break;
                            }
                        }

                        outer_faces[face_index] = outer_face;
                        outer_faces[face_index].dihedral_angle = face.dihedral_angle;

                        // Footing parameters computing
                        // On the two last crown, check if points are far enough
                        // Take vectors and points from outer/inner faces to build a Footing timber
                        if (
                            // For the last Triangle
                            (face.num_points === 3 && face_index + 1 == num_zome_faces)

                            // For truncated kite
                            || (face.num_points === 5 && face_index + 2 == num_zome_faces)

                            // For bottom part of the last rhombus in bindu case
                            || (face.is_bottom_part && face.num_points === 4 && face_index + 2 == num_zome_faces)
                        ) {
                            const start_index = (face.num_points === 5) ? 1 : 0;
                            [B, D, F, H] = [
                                outer_face_points[start_index + 1], // outer top left corner
                                outer_face_points[start_index + 2], // outer top right corner
                                inner_face_points[start_index + 1], // inner top left corner
                                inner_face_points[start_index + 2], // inner top right corner
                            ]

                            _.forEach([B, D, F, H], p => {
                                lowest_vertical_position = Math.min(p[1], lowest_vertical_position);
                            });

                            // Add Footing params to build prism later with the lowest_vertical_position variable
                            footing_params.push([B, D, F, H]);
                        }

                        // Add a dihedral angle to timber, because we need face plane to compute it
                        for (let k = 0; k < face.framework_timbers.length; k++) {
                            const timber = face.framework_timbers[k];
                            timber.dihedral_angle = Math.PI - angle_between_planes(
                                timber.get_face("front").plane,
                                face.plane,
                            );
                        }

                        // Add skeleton crown
                        skeleton_crowns[face_index] = new Base3DGeometryCrown(
                            face,
                            [
                                inner_faces[face_index],
                                outer_faces[face_index],
                            ],
                            face.framework_timbers,
                            null,
                            face.label,
                            face.color,
                            face.crown_index,
                        );
                    }

                    // Build Footing timbers
                    const footing_thickness = (this.params.add_footing === 1) ? TIMBER_THICKNESS : 0
                    const floor_vertical_position = lowest_vertical_position - footing_thickness;
                    const floor_plane = plane_on_axis("Y", floor_vertical_position);
                    let picked_outer_floor_points = [], picked_inner_floor_points = [];
                    const go_to_ground_vec = [0, -1, 0];

                    _.forEach(footing_params, (params, footing_index) => {
                        const [B, D, F, H] = params;

                        const [A, C, E, G] = [
                            plan_intersection(B, go_to_ground_vec, floor_plane),
                            plan_intersection(D, go_to_ground_vec, floor_plane),
                            plan_intersection(F, go_to_ground_vec, floor_plane),
                            plan_intersection(H, go_to_ground_vec, floor_plane),
                        ]

                        if (this.params.add_footing === 1) {
                            // Add a tilde to the Footing label
                            const timber_label = `~${footing_index + 1}`;
                            const timber_prism = new TrapezoidalPrism([A, B, C, D, E, F, G, H], timber_label);

                            // Add Footing timber to the global skeleton
                            skeleton.push(timber_prism);
                        }

                        // Add points for outer floor
                        picked_outer_floor_points.push(A);
                        picked_outer_floor_points.push(C);

                        picked_inner_floor_points.push(E);
                        picked_inner_floor_points.push(G);
                    });

                    // Rotate picked floor points
                    let outer_floor_points = [], inner_floor_points = [];
                    _.forEach(rotation_angles, angle => {
                        inner_floor_points.push(...rotate_points_around_y_axis(picked_inner_floor_points, angle));
                        outer_floor_points.push(...rotate_points_around_y_axis(picked_outer_floor_points, angle));
                    });

                    // Remove duplicates and create floors ⬢
                    outer_floor_points = _.uniqWith(outer_floor_points, are_points_far_enough);
                    inner_floor_points = _.uniqWith(inner_floor_points, are_points_far_enough);
                    const outer_floor = (outer_floor_points.length >= 3) ? new Polygon3D(outer_floor_points, FLOOR_CHAR) : null;
                    const inner_floor = (inner_floor_points.length >= 3) ? new Polygon3D(inner_floor_points, FLOOR_CHAR) : null;

                    // Group items by hash
                    const obj_3D_to_label = [
                        skeleton,
                        skeleton_crowns,
                    ];

                    const arr_of_obj_groups = new Array(obj_3D_to_label.length);
                    for (let i = 0; i < obj_3D_to_label.length; i++) {
                        const obj_3D = obj_3D_to_label[i];
                        arr_of_obj_groups[i] = _.map(_.groupBy(obj_3D, item => item.hash), (group, hash) => {
                            // Update label of each member
                            for (let j = 1; j < group.length; j++) {
                                group[j].set_label(group[0].label);
                            }
                            return new ItemHashGroup(group[0], hash, group.length * N);
                        });
                    }

                    // 🎨 Add colors to items and build rotated colors
                    _.forIn(arr_of_obj_groups, (obj_groups, i) => {
                        // Get hash group
                        const hashes = obj_groups.map(group => group.hash);
                        const num_hashes = hashes.length;

                        // Associates a hash to a color
                        const hash_to_color = {};
                        _.forIn(hashes, (hash, j) => {
                            if (!hash_to_color.hasOwnProperty(hash)) {
                                hash_to_color[hash] = Color.from_index(j, num_hashes);
                            }
                        });

                        _.forEach(obj_3D_to_label[i], item => {
                            item.set_color(hash_to_color[item.hash]);
                        });
                    });

                    // Compute rotated_colors if you decide to paint spiral colors in the 2D drawing
                    let rotated_colors = {};
                    for (let face_index = 0; face_index < num_zome_faces; face_index++) {
                        const face = zome_faces_3D[face_index];
                        if (!rotated_colors.hasOwnProperty(face.color.hex)) {
                            rotated_colors[face.color.hex] = _.map(rotation_angles, a => Color.from_angles(a.rad, face.normalized_slope));
                        }
                    }

                    // Unpack variables
                    const [
                        timber_profiles_grouped_by_hash,
                        timbers_grouped_by_face,
                    ] = arr_of_obj_groups;

                    const num_faces_grouped_by_hash = timbers_grouped_by_face.length;
                    const outer_faces_grouped_by_hash = new Array(num_faces_grouped_by_hash);
                    const inner_faces_grouped_by_hash = new Array(num_faces_grouped_by_hash);
                    for (let hash_group_index = 0; hash_group_index < num_faces_grouped_by_hash; hash_group_index++) {
                        const hash_group = timbers_grouped_by_face[hash_group_index];

                        inner_faces_grouped_by_hash[hash_group_index] = new ItemHashGroup(
                            hash_group.item.linked_faces[0],
                            hash_group.hash,
                            hash_group.count,
                        )

                        outer_faces_grouped_by_hash[hash_group_index] = new ItemHashGroup(
                            hash_group.item.linked_faces[1],
                            hash_group.hash,
                            hash_group.count,
                        );
                    }

                    // Build Mandala
                    const flattened_faces = new Array(zome_faces_3D.length);
                    let rotation_angle = null,
                        hook_pt = null,
                        rotation_pt1 = null,
                        rotation_pt2 = null;

                    for (let face_index = 0; face_index < num_zome_faces; face_index++) {
                        const face = zome_faces_3D[face_index];
                        let flattened_points = face.put_face_on_the_ground().points;
                        const num_points = flattened_points.length;

                        // Move to an custom origin and rotate to match with previous piece
                        if (face_index > 0) {
                            flattened_points = flattened_points.map(p => {
                                return add(p, hook_pt);
                            });

                            switch (face.part) {
                                case "right":
                                case "bottom":
                                    break;
                                case "top":
                                case "left":
                                default:
                                    // Compute rotation
                                    rotation_pt1 = flattened_points[1];
                                    rotation_angle = Angle.from_3_points(rotation_pt1, hook_pt, rotation_pt2);

                                    const rotated_pt1 = rotate_point_around_y_axis(rotation_pt1, rotation_angle, hook_pt);

                                    // Rotate the other way if second point rotated
                                    // is not too close to the before last point
                                    if (to_decimal(dist(rotated_pt1, rotation_pt2)) !== 0) {
                                        rotation_angle = rotation_angle.reverse();
                                    }
                                    break;
                            }

                            flattened_points = flattened_points.map(p => {
                                return rotate_point_around_y_axis(p, rotation_angle, hook_pt);
                            });
                        }

                        // Move to Origin and rotate to match with previous piece
                        switch (face.part) {
                            case "left":
                                hook_pt = flattened_points[0];
                                break;
                            case "top":
                                hook_pt = flattened_points[1];
                                break;
                            case "right":
                            case "bottom":
                            default:
                                hook_pt = flattened_points[num_points - 1];
                                rotation_pt2 = flattened_points[num_points - 2];
                                break;
                        }


                        // Swap y-axis with z axis for 3D display
                        flattened_faces[face_index] = Polygon3D.copy(face, flattened_points);
                    }

                    // Compute Zome Height
                    let zome_y_min = Number.MAX_VALUE, zome_y_max = Number.MIN_VALUE;
                    for (let timber_index = 0; timber_index < skeleton.length; timber_index++) {
                        const timber = skeleton[timber_index];
                        if (timber.y_min < zome_y_min) zome_y_min = timber.y_min;
                        if (timber.y_max > zome_y_max) zome_y_max = timber.y_max;
                    }

                    // Save Zome and dispatch it
                    ZOME = new Zome({
                        num_spirals: N,
                        y_min: zome_y_min,
                        y_max: zome_y_max,

                        rotation_angles: rotation_angles,
                        rotated_colors: rotated_colors,

                        assembly_method: ASSEMBLY_METHOD,
                        skeleton: skeleton,
                        timber_profiles_grouped_by_hash: timber_profiles_grouped_by_hash,
                        timbers_grouped_by_face: timbers_grouped_by_face,

                        outer_faces: outer_faces,
                        outer_faces_grouped_by_hash: outer_faces_grouped_by_hash,
                        outer_floor: outer_floor,

                        inner_faces: inner_faces,
                        inner_faces_grouped_by_hash: inner_faces_grouped_by_hash,
                        inner_floor: inner_floor,

                        flattened_faces: flattened_faces,

                        vanishing_lines: vanishing_lines,
                    });

                    // Dispatch zome
                    this.$dispatch('zome-is-made');

                    // Reset selected crown index
                    this.num_crowns = num_crowns;
                    this.num_points_per_crown = num_points_per_crown;

                    // Force face divisions
                    this.update_face_divisions();

                    sync_url_from_params(this.params);

                    this.is_computing = false;
                    this.show_splash_screen = false;
                },
            };
        });
    })
    ;
</script>
<!-- Custom Javascript -->
</body>
</html>

