<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
    <title>Z5omes | A Zome Maker</title>

    <!-- Stylesheets -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/fa.min.css" rel="stylesheet">
    <link href="css/custom.css" rel="stylesheet">
</head>

<body class="bg-light">
<div class="container-xl row m-auto">
    <div class="col mb-3 mt-3">
        <div class="d-flex align-items-center">
            <h2 id="#title" class="text-primary me-auto mb-0">
                <img src="img/logo_zome.svg" width="48" alt="Zome Logo">
                Z<span class="fs-4">o</span>oOo<span
                    class="fs-4">o</span>mes
            </h2>
            <a href="https://github.com/florianwns/z5omes"
               class="text-primary btn btn-sm fs-4 p-2" title="Go to Github">
                <i class="fa-brands fa-github"></i>
            </a>
        </div>

        <div x-data="settings" @zome-renderer-is-ready.window="__make_zome">
            <hr>
            <div class="d-flex align-items-center">
                <h5 class="text-secondary mt-4 mb-4 me-auto">
                    <i class="fa-solid fa-rhombus fa-fw"></i>
                    Shape
                </h5>
                <!-- Randomize Button -->
                <button @click="randomize" class="btn btn-primary btn-sm p-2" title="Randomize settings">
                    <i class="fa-solid fa-dice fa-fw"></i>
                </button>
            </div>

            <!-- Num of Order -->
            <div class="input-group input-group-sm mb-3">
                <span class="input-group-text" title="Num of order">N</span>
                <input class="form-control form-range" max="21" min="3" step="1" type="range"
                       x-model.number="num" x-ref="num_slider">
                <input class="form-control" step="1" type="number"
                       x-model.lazy.number="num">
            </div>

            <!-- Num of rhombus from the top -->
            <div class="input-group input-group-sm mb-3">
                <span class="input-group-text" title="Num of rhombus from the top">M</span>
                <input class="form-control form-range" :max="num - 1" min="1" step="1" type="range"
                       x-model.number="num_rhombus" x-ref="num_rhombus_slider">
                <input class="form-control" step="1" type="number"
                       x-model.lazy.number="num_rhombus">
            </div>

            <!-- First Vertical Angle of Zome -->
            <div class="input-group input-group-sm mb-3">
                <button class="btn btn-secondary text-start" type="button"
                        title="First Vertical Angle of Zome"
                        @click="angle_unit = (angle_unit == 'tan') ? 'deg': 'tan'"
                        x-text="(angle_unit == 'tan') ? 'F' : 'Θ'">
                </button>
                </span>
                <input class="form-control form-range" min="30" max="70" step="0.01" type="range"
                       x-model.number="theta_deg" x-ref="theta_deg_slider">
                <input class="form-control" type="number" step="0.01" x-model.lazy.number="theta">
                <select class="form-select" aria-label="Angle unit"
                        x-show="angle_unit != 'tan'" x-model="angle_unit">
                    <option selected value="deg">deg</option>
                    <option value="rad">rad</option>
                    <option hidden value="tan">tan</option>
                </select>
            </div>

            <hr>

            <!-- Height Ratio of Zome -->
            <div class="input-group input-group-sm mb-3">
                <span class="input-group-text">HR</span>
                <input class="form-control form-range" max="1" step="0.000001" type="range"
                       :min="toDecimal(2 / num, FLOAT_PRECISION)"
                       x-model.number="height_ratio" x-ref="height_ratio_slider">
                <input class="form-control" step="0.01" type="number"
                       x-model.lazy.number="height_ratio">
                <button class="btn btn-primary" title="Magnetize" type="button"
                        :disabled="height_ratio == suggested_height_ratio" @click="magnetize">
                    <i class="fa-solid fa-magnet fa-fw"></i>
                </button>
            </div>

            <!-- Kite Ratio of Zome -->
            <div class="input-group input-group-sm mb-3">
                <span class="input-group-text">
                    KR
                </span>
                <input class="form-control form-range" max="1.5" min="0.5" step="0.01" type="range"
                       x-model.number="kite_ratio" x-ref="kite_ratio_slider">
                <input class="form-control" step="0.01" type="number"
                       x-model.lazy.number="kite_ratio">
                <button class="btn btn-primary"
                        title="Set rhombus" type="button"
                        :disabled="is_rhombus" @click="is_rhombus = true">
                    <i class="fa-solid fa-rhombus"></i>
                </button>
            </div>
        </div>
    </div>
    <div class="col-md-6 col-xl-7 mb-3">
        <div class="d-flex flex-column">
            <nav class="navbar mx-auto mt-2">
                <ul class="nav nav-pills" id="nav-tab" role="tablist">
                    <li class="nav-item">
                        <button class="nav-link active" id="nav-3D-tab" data-bs-toggle="tab"
                                data-bs-target="#nav-3D"
                                type="button" role="tab" aria-controls="nav-3D" aria-selected="true">
                            <i class="fa-solid fa-chart-pyramid fa-fw"></i>
                            3D View
                        </button>
                    </li>
                    <li>
                        <button class="nav-link" id="nav-2D-tab" data-bs-toggle="tab"
                                data-bs-target="#nav-2D"
                                type="button" role="tab" aria-controls="nav-2D" aria-selected="false">
                            <i class="fa-solid fa-triangle fa-fw"></i>
                            2D View
                        </button>
                    </li>
                    <li>
                        <button class="nav-link" id="nav-help-tab" data-bs-toggle="tab"
                                data-bs-target="#nav-help" type="button" role="tab"
                                aria-controls="nav-help"
                                aria-selected="false">

                            <i class="fa-solid fa-question-circle fa-fw"></i>
                            Help
                        </button>
                    </li>
                </ul>
            </nav>
            <div class="tab-content h-100 mt-3">
                <div class="tab-pane show active" id="nav-3D" role="tabpanel" aria-labelledby="nav-3D-tab"
                     tabindex="0" x-data="renderer_3D" @resize.window="auto_size"
                     @zome-is-made.window="process($event.detail);">
                    <div class="d-flex justify-content-center">
                        <div style="width:calc(100% - 48px)">
                            <!-- Canvas for Zome 3D rendering -->
                            <div x-ref="canvas" style="height:326px; cursor: move;"
                                 class="shadow bg-dark rounded mb-2"></div>

                            <div class="d-flex flex-wrap justify-content-evenly">
                                <!-- Draw Axis -->
                                <div class="form-check form-switch me-2 mb-3">
                                    <label class="form-check-label" for="draw-axis-switch">Axis</label>
                                    <input class="form-check-input" type="checkbox" role="switch"
                                           id="draw-axis-switch" x-model="draw_axis">
                                </div>

                                <!-- Draw Vertices -->
                                <div class="form-check form-switch me-2 mb-3">
                                    <label class="form-check-label" for="draw-vertices-switch">Vertices</label>
                                    <input class="form-check-input" type="checkbox" role="switch"
                                           id="draw-vertices-switch" x-model="draw_vertices">
                                </div>

                                <!-- Draw Faces -->
                                <div class="form-check form-switch me-2 mb-3">
                                    <label class="form-check-label" for="draw-faces-switch">Faces</label>
                                    <input class="form-check-input" type="checkbox" role="switch"
                                           id="draw-faces-switch" x-model="draw_faces">
                                </div>

                                <!-- Spin -->
                                <div class="form-check form-switch mb-3">
                                    <label class="form-check-label" for="spin-switch">Spin</label>
                                    <input class="form-check-input" type="checkbox" role="switch"
                                           id="spin-switch" x-model="is_spinning">
                                </div>
                            </div>
                        </div>

                        <div class="ps-2 flex-shrink-1">
                            <div class="vstack">
                                <span class="text-primary btn btn-sm fs-2 px-2 position-relative" title="Save to OBJ">
                                    <i class="fa-solid fa-file"></i>
                                    <span class="fa-icon-file-type">OBJ</span>
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="tab-pane" id="nav-2D" role="tabpanel" aria-labelledby="nav-2D-tab" tabindex="0"
                     x-data="renderer_2D" @resize.window="auto_size"
                     @zome-is-made.window="process($event.detail);">
                    <div class="d-flex justify-content-center">
                        <div class="ratio ratio-A4 bg-white rounded border" style="width:300px">
                            <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewbox="0 0 210 297">
                                <polygon points="16,0,0,14.246855049505413,16,28.493710099010844,32,14.246855049505417"
                                stroke="red"/>
                            </svg>
                        </div>
                        <div class="ps-2">
                            <div class="vstack">
                                <span class="text-primary btn btn-sm fs-2 px-2 position-relative" title="Save to PDF">
                                    <i class="fa-solid fa-file"></i>
                                    <span class="fa-icon-file-type">PDF</span>
                                </span>
                                <span class="text-primary btn btn-sm fs-2 px-2 position-relative" title="Save to SVG">
                                    <i class="fa-solid fa-file"></i>
                                    <span class="fa-icon-file-type">SVG</span>
                                </span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="tab-pane" id="nav-help" role="tabpanel" aria-labelledby="nav-help-tab" tabindex="0">
                    <div class="card help-content small">
                        <div class="card-header">
                            How make your zome ?
                        </div>
                        <div class="card-body ">
                            <p>The shape of a <a href="https://en.wikipedia.org/wiki/Zome">zome</a> is
                                determined by 3 parameters:</p>
                            <ul>
                                <li>
                                    <b>N</b> : Number of edges starting from the top of zome.
                                </li>
                                <li>
                                    <b>M</b> : Number of
                                    <a href="https://en.wikipedia.org/wiki/Rhombus">rhombus</a>
                                    from top to bottom.
                                </li>
                                <li>
                                    <b>Θ</b> : First vertical angle of zome, related to the slope of the edges.
                                    <span class="text-muted">F = tan(Θ) </span>
                                </li>
                            </ul>
                            <p>There are two additional parameters to refine your zome :</p>
                            <ul>
                                <li>
                                    <b>HR</b> : The height ratio.
                                    <br><span class="text-muted">Set HR to 1 for an entire zome.</span>
                                </li>
                                <li>
                                    <b>KR</b> : The Kite ratio. Change rhombus faces to kite faces.
                                    <br><span class="text-muted">Set KR to 1 for rhombus faces.</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="col-12 break-before" x-data="measurements" @zome-is-made.window="process($event.detail);">
        <hr>
        <h5 class="text-secondary mt-4 mb-4 me-auto">
            <i class="fa-solid fa-ruler-triangle fa-fw"></i>
            Measurements
        </h5>

        <div class="row">
            <div class="col mb-4">
                <!-- Height of Zome -->
                <div class="input-group input-group-sm mb-3">
                    <span class="input-group-text" title="Height of zome">Height</span>
                    <input class="form-control form-range" min="1" max="9999" step="1" type="range"
                           x-model.number="height" x-ref="height_slider">

                    <input class="form-control" step="0.01" type="number"
                           x-model.lazy.number="height">

                    <select class="form-select" aria-label="Length unit" x-model="length_unit">
                        <option selected value="mm">mm</option>
                        <option value="cm">cm</option>
                        <option value="m">m</option>
                    </select>
                </div>

                <ul class="list-group small">
                    <li class="list-group-item d-flex justify-content-between align-items-center">
                        Body Num Pieces
                        <span class="badge bg-info rounded-pill" x-text="body_num_pieces"></span>
                    </li>
                    <li class="list-group-item d-flex justify-content-between align-items-center">
                        Body Widest Ø
                        <span class="badge bg-info rounded-pill" x-text="widest_diameter"></span>
                    </li>
                    <li class="list-group-item d-flex justify-content-between align-items-center">
                        Body Area
                        <span class="badge bg-info rounded-pill" x-text="body_area"></span>
                    </li>
                    <li class="list-group-item d-flex justify-content-between align-items-center border-top"
                        x-show.important="has_base">
                        Base Ø
                        <span class="badge bg-info rounded-pill" x-text="base_diameter"></span>
                    </li>
                    <li class="list-group-item d-flex justify-content-between align-items-center"
                        x-show.important="has_base">
                        Base Area
                        <span class="badge bg-info rounded-pill" x-text="base_area"></span>
                    </li>
                    <li class="list-group-item d-flex justify-content-between align-items-center"
                        x-show.important="has_base">
                        Base Perimeter
                        <span class="badge bg-info rounded-pill" x-text="base_perimeter"></span>
                    </li>
                </ul>
            </div>

            <div class="col-md-6 col-xl-7 mb-3">
                <!--                <div class="card w-100 bg-secondary">-->
                <!--                    <div class="ratio ratio-A4 bg-primary">-->

                <!--                    </div>-->
                <!--                </div>-->
            </div>
            <div class="col-12 mb-5">
                <div class="table-responsive border border-bottom-0 bg-white rounded">
                    <table x-ref="dim-table" class="table  table-sm small table-striped-order m-0">
                        <thead class="bg-info text-white">
                        <tr>
                            <th>#</th>
                            <th></th>
                            <th>Width</th>
                            <th>Height</th>
                            <!--                            <th>Top Height</th>-->
                            <!--                            <th>Bottom Height</th>-->
                            <th>CCW Edges</th>
                            <th>CCW Angles</th>
                            <th>θ (Slope angle)</th>
                            <th>σ (Dihedral angle)</th>
                            <th>Area</th>
                            <th>Ø</th>
                        </tr>
                        </thead>
                        <tbody>
                        <template x-for="(obj, i) in pieces" :key="i">
                            <tr>
                                <td x-text="i + 1"></td>
                                <td>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32"
                                         :fill="obj.color">
                                        <polygon :points="to_svg_polygon(obj, 32)"/>
                                    </svg>
                                </td>
                                <td x-text="reprDistance(obj.width)"></td>
                                <td x-text="reprDistance(obj.height)"></td>
                                <!--                                <td x-text="toDecimal(obj.top_height)"></td>-->
                                <!--                                <td x-text="toDecimal(obj.bottom_height)"></td>-->
                                <td x-text="reprArr(uniqueArr(_.map(obj.edge_distances, v => reprDistance(v))))"></td>
                                <td x-text="reprArr(uniqueArr(_.map(obj.angles, a => reprAngle(rad2deg(a)))))"></td>
                                <td x-text="reprAngle(rad2deg(obj.slope))"></td>
                                <td x-text="reprAngle(rad2deg(obj.σ))"></td>
                                <td x-text="reprArea(obj.area)"></td>
                                <td x-text="reprDistance(obj.diameter)"></td>
                            </tr>
                        </template>
                        </tbody>
                        <tfoot>
                        </tfoot>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Scripts / Bootstrap 5 runs without jQuery -->
<script src="js/bootstrap.min.js"></script>

<!-- Lodash -->
<script src="js/lodash.min.js"></script>

<!-- Geometry functions -->
<script src="js/geom.js"></script>

<!-- ThreeJS -->
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>

<!-- Alpine JS -->
<script defer src="js/alpine.min.js"></script>

<!-- Custom Javascript -->
<script type="text/javascript">
    const WORLD_HEIGHT = 100;
    const FLOAT_PRECISION = 6;
    const ALPHABET = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];

    document.addEventListener('alpine:init', () => {
        Alpine.data('measurements', () => {
            let virtual_pieces = [];
            let num = 0;

            return {
                pieces: [],
                body: [],
                has_base: false,
                height: 100,                // Height
                length_unit: "mm",          // Length unit by default is mm

                __to_real_world: null,
                async init() {
                    this.__to_real_world = _.debounce(this.to_real_world, 1);

                    this.$watch("height", (value) => {
                        this.clamp("height", value);
                        this.__to_real_world();
                    });

                    this.$watch("length_unit", () => this.__to_real_world());
                },
                get base() {
                    // Only the base
                    return this.has_base ? this.pieces[this.pieces.length - 1] : null;
                },
                get widest_diameter() {
                    const value = _.reduce(this.body, (res, p) => Math.max(res, p.diameter), Number.MIN_VALUE);
                    return reprDistance(value);
                },
                get body_area() {
                    const value = _.reduce(this.body, (res, p) => res + p.area * num, 0);
                    return reprArea(value);
                },
                get body_num_pieces() {
                    return num * this.body.length;
                },
                get base_diameter() {
                    const value = this.base ? this.base.diameter : 0;
                    return reprDistance(value);
                },
                get base_area() {
                    const value = this.base ? this.base.area : 0
                    return reprArea(value);
                },
                get base_perimeter() {
                    const value = this.base ? this.base.perimeter : 0
                    return reprDistance(value);
                },
                format(key, value) {
                    return toDecimal(value, 2);
                },
                format_str(value, unit) {
                    switch (key) {
                        default:
                            return toDecimal(value, FLOAT_PRECISION);
                    }
                },
                get_slider(key) {
                    return eval(`this.$refs.${key}_slider`);
                },
                clamp(key, value) {
                    const slider = this.get_slider(key);
                    this[key] = this.format(key, _.clamp(value, slider.min, slider.max));
                },
                is_valid(obj) {
                    const hasKey = (res, key) => res && obj.hasOwnProperty(key);
                    return !(!obj || !["pieces", "num"].reduce(hasKey, true));
                },
                process(zome) {
                    if (!this.is_valid(zome)) {
                        console.error("Object is not valid", zome)
                        return;
                    }

                    virtual_pieces = zome.pieces;
                    num = zome.num;

                    this.__to_real_world();
                },
                to_svg_polygon(piece, size) {
                    // Recompute pixel positions
                    const center = size / 2;
                    const pixel_ratio = size / Math.max(piece.height, piece.width);
                    return piece.points_2d.map(p => [p[0] * pixel_ratio + center, p[1] * pixel_ratio]);
                },
                to_real_world() {
                    // Clone pieces
                    const pieces = _.cloneDeep(virtual_pieces);

                    // Compute height ratio then convert dimensions to real world
                    const num_pieces = pieces.length;
                    const yMax = pieces[0].points[0][1];
                    const yMin = pieces[num_pieces - 1].points[1][1];
                    const real_size_ratio = to_mm(this.height / (yMax - yMin), this.length_unit);

                    for (let iP = 0; iP < num_pieces; iP++) {
                        const piece = pieces[iP];
                        piece.points = piece.points.map(p => [
                            p[0] * real_size_ratio,
                            p[1] * real_size_ratio - yMin,
                            p[2] * real_size_ratio
                        ]);
                        piece.compute();

                        // Compute σ, the Dihedral angle only for the Zome body
                        if (piece instanceof PolygonWithHat) {
                            if (iP == 0) {
                                const next_piece = pieces[iP + 1];
                                piece.σ = dihedral_angle(next_piece.φ, piece.ω, piece.ω);
                            } else {
                                const prev_piece = pieces[iP - 1];
                                const α = angle(piece.A, piece.B, prev_piece.B);
                                const δ = angle(piece.A, piece.B, piece.C);
                                const λ = angle(prev_piece.B, piece.B, piece.C);
                                piece.σ = dihedral_angle(λ, δ, α);
                            }
                        }
                    }

                    // Refresh proxy
                    this.pieces = pieces;

                    // All pieces without the zome base
                    this.body = _.filter(this.pieces, p => !(p instanceof ZomeBase));
                    this.has_base = (this.body.length + 1) === this.pieces.length;
                },
            };
        });
        Alpine.data('renderer_2D', () => {
            return {
                // 2D Rendering Parameters
                init() {
                    // Add listeners

                },
                is_valid(obj) {
                    const hasKey = (res, key) => res && obj.hasOwnProperty(key);
                    return !(!obj || !["vertices", "faces"].reduce(hasKey, true));
                },
                process(zome) {
                    if (!this.is_valid(zome)) {
                        console.error("Object is not valid", zome)
                        return;
                    }

                    console.log("Render 2D");
                },
            };
        });

        Alpine.data('renderer_3D', () => {
            let scene, camera, renderer, controls, canvas;              // Three JS Parameters
            const meshes = {
                "axis": null,
                "zome": null, // Group of faces and vertices
                "faces": null,
                "vertices": null,
            }

            return {
                // 3D Rendering Parameters
                is_spinning: true,
                speed: 0.005,

                draw_axis: true,
                draw_vertices: false,
                draw_faces: true,

                init() {
                    // Add listeners
                    this.$el.addEventListener("keydown", e => this.keydown(e), false);

                    ["axis", "vertices", "faces"].forEach(
                        (key) => this.$watch(`draw_${key}`, (value) => {
                            this.set_visibility(key, value);
                        })
                    );

                    // Set Canvas Parameters
                    canvas = this.$refs.canvas;
                    const [width, height] = [canvas.offsetWidth, canvas.offsetHeight]

                    // Renderer
                    renderer = new THREE.WebGLRenderer({alpha: true, antialias: true});
                    canvas.appendChild(renderer.domElement);

                    // Scene
                    scene = new THREE.Scene();

                    // Camera ( x is red, y is green, z is blue)
                    const [field_of_view, aspect_ratio, near, far] = [75, width / height, 0.1, 10 * WORLD_HEIGHT]
                    camera = new THREE.PerspectiveCamera(field_of_view, aspect_ratio, near, far);
                    camera.position.copy(this.home);

                    // Add controls
                    controls = new THREE.OrbitControls(camera, renderer.domElement);

                    // Add (x, y, z) Axis
                    meshes.axis = new THREE.AxesHelper(WORLD_HEIGHT);
                    meshes.axis.visible = this.draw_axis;
                    scene.add(meshes.axis);

                    this.reset();
                    this.auto_size()
                    this.animate()

                    this.$dispatch('zome-renderer-is-ready');
                },
                auto_size() {
                    const [width, height] = [canvas.offsetWidth, canvas.offsetHeight]
                    if (width > 0 && height > 0) {
                        camera.aspect = width / height;
                        camera.updateProjectionMatrix();
                        renderer.setSize(width, height);
                    }
                },
                is_valid(obj) {
                    const hasKey = (res, key) => res && obj.hasOwnProperty(key);
                    return !(!obj || !["vertices", "faces"].reduce(hasKey, true));
                },
                process(zome) {
                    if (!this.is_valid(zome)) {
                        console.error("Object is not valid", zome)
                        return;
                    }

                    // Clean old mesh
                    if (meshes.zome instanceof THREE.Group) {
                        scene.remove(meshes.zome)
                    }
                    meshes.zome = new THREE.Group();

                    // Draw vertices
                    {
                        const vertices = new Float32Array(zome.vertices.flat())
                        const geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                        const material = new THREE.PointsMaterial({color: 0xFF0000, size: 0.25})

                        // Add to group
                        meshes.vertices = new THREE.Points(geometry, material)
                        meshes.vertices.visible = this.draw_vertices;
                        meshes.zome.add(meshes.vertices);
                    }

                    // Draw faces
                    const color_face = false;
                    if (color_face) {
                        const points = [];
                        const colors = [];
                        const num_pieces = zome.pieces.length;
                        for (let iP = 0; iP < num_pieces; iP++) {
                            const faces = zome.pieces[iP].faces;
                            const rgb = zome.pieces[iP].rgb;
                            for (let iF = 0; iF < faces.length; iF++) {
                                const vectors = _.map(faces[iF].points, p => new THREE.Vector3(...p));
                                points.push(...vectors);
                                colors.push(...rgb);  // r, g, b
                                colors.push(...rgb);  // r, g, b
                                colors.push(...rgb);  // r, g, b
                            }
                        }

                        const material = new THREE.MeshBasicMaterial({
                            side: THREE.DoubleSide,
                            vertexColors: true,
                        });

                        const geometry = new THREE.BufferGeometry()
                        geometry.setFromPoints(points)
                        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                        geometry.computeVertexNormals()

                        // Add to group
                        meshes.faces = new THREE.Mesh(geometry, material)
                        meshes.faces.visible = this.draw_faces;
                        meshes.zome.add(meshes.faces);
                    } else {
                        const points = zome.faces.map(p => new THREE.Vector3(...p));
                        const material = new THREE.MeshNormalMaterial({side: THREE.DoubleSide})
                        const geometry = new THREE.BufferGeometry()
                        geometry.setFromPoints(points)
                        geometry.computeVertexNormals()

                        // Add to group
                        meshes.faces = new THREE.Mesh(geometry, material)
                        meshes.faces.visible = this.draw_faces;
                        meshes.zome.add(meshes.faces);
                    }

                    // Add the final obj mesh to the scene
                    scene.add(meshes.zome)
                },
                get right() {
                    return new THREE.Vector3(WORLD_HEIGHT * 1.5, WORLD_HEIGHT * 0.5, 0);
                },
                get left() {
                    return new THREE.Vector3(0, WORLD_HEIGHT * 0.5, WORLD_HEIGHT * 1.5);
                },
                get down() {
                    return new THREE.Vector3(0, -WORLD_HEIGHT * 1.20, 0);
                },
                get up() {
                    return new THREE.Vector3(0, WORLD_HEIGHT * 1.50, 0);
                },
                get home() {
                    const axis = new THREE.Vector3(0, 1, 0);
                    const angle = Math.PI / 4;
                    return this.left.applyAxisAngle(axis, angle);
                },
                set_visibility(key, value) {
                    if (meshes.hasOwnProperty(key) && meshes[key].hasOwnProperty("visible")) {
                        meshes[key].visible = value
                    }
                },
                update() {
                    if (this.is_spinning && meshes.zome instanceof THREE.Group) {
                        meshes.zome.rotation.y -= this.speed
                    }
                },
                render() {
                    renderer.render(scene, camera)
                },
                animate() {
                    this.update()
                    this.render()
                    requestAnimationFrame(this.animate.bind(this));
                },
                move(v) {
                    camera.position.copy(v);
                    controls.update();
                },
                reset() {
                    this.speed = 0.003;
                    controls.reset();
                    controls.target.set(0, WORLD_HEIGHT / 2.5, 0);
                    controls.update();
                },
                keydown(e) {
                    switch (e.key) {
                        case "*":
                            this.speed += 0.001;
                            break;
                        case "/":
                            this.speed -= 0.001;
                            break;
                        case " ":
                            this.is_spinning = !this.is_spinning;
                            break;
                        case "h":
                        case "H":
                            this.reset();
                            break;
                        case "Down":
                        case "ArrowDown":
                            this.move(this.down);
                            break;
                        case "Up":
                        case "ArrowUp":
                            this.move(this.up);
                            break;
                        case "Left":
                        case "ArrowLeft":
                            this.move(this.left);
                            break;
                        case "Right":
                        case "ArrowRight":
                            this.move(this.right);
                            break;
                        default:
                            return;
                    }
                    e.preventDefault();
                },
            };
        });

        Alpine.data('settings', () => {
            let vertices = [];
            let faces = [];
            let iTriangles = [];
            let pieces = [];
            let colors = [];

            return {
                // Shape Parameters
                num: 7,                     // number of faces (kites or diamonds)
                theta_deg: 50,              // In degrees, vertical angle of top struts
                angle_unit: "deg",          // Degrees or Radians
                height_ratio: 0.714286,           // Height ratio as proportion of pole-to-pole distance (0.5 => middle)
                kite_ratio: 1,                   // Kite ratio, lower half to upper half (1 => is rhombus else kites)
                suggested_height_ratio: null,    // Value to magnetize the zome to the nearest cut
                colors: [],

                // Debouncers
                __make_zome: null,

                async init() {
                    this.__make_zome = _.debounce(this.make_zome, 1);

                    // Add shape parameter listeners
                    ["num", "theta_deg", "height_ratio", "kite_ratio"].forEach(
                        (key) => this.$watch(key, (value) => {
                            this.clamp(key, value);
                            this.__make_zome();
                        })
                    );

                    // Refresh the height_ratio if you change the zome num
                    this.$watch("num", (value) => {
                        this.clamp("height_ratio", this.height_ratio);
                    });
                },
                get theta() {
                    switch (this.angle_unit) {
                        case "rad":
                            return toDecimal(deg2rad(this.theta_deg), FLOAT_PRECISION);
                        case "tan":
                            return toDecimal(Math.tan(deg2rad(this.theta_deg)), FLOAT_PRECISION);
                        case "deg":
                        default:
                            return this.theta_deg;
                    }
                },
                set theta(angle) {
                    switch (this.angle_unit) {
                        case "rad":
                            this.theta_deg = rad2deg(angle)
                            break;
                        case "tan":
                            this.theta_deg = rad2deg(Math.atan(angle))
                            break;
                        case "deg":
                        default:
                            this.theta_deg = angle;
                    }
                },
                get num_rhombus() {
                    return toDecimal(this.num * this.height_ratio - 1);
                },
                set num_rhombus(value) {
                    this.kite_ratio = 1;
                    this.height_ratio = toDecimal((value + 1) / this.num, FLOAT_PRECISION);
                },
                get is_rhombus() {
                    return this.kite_ratio === 1;
                },
                set is_rhombus(value) {
                    if (value === true) {
                        this.kite_ratio = 1
                    }
                },
                magnetize() {
                    if (this.suggested_height_ratio && this.suggested_height_ratio != this.height_ratio) {
                        this.height_ratio = this.suggested_height_ratio;
                    }
                },
                format(key, value) {
                    // Format Zome parameters by pair of [key, value]
                    switch (key) {
                        case 'num':
                            return toDecimal(value, 0);
                        default:
                            return toDecimal(value, FLOAT_PRECISION);
                    }
                },
                randomize() {
                    ["num", "theta_deg", "num_rhombus"].forEach(
                        (key) => {
                            const slider = this.get_slider(key);
                            this[key] = _.random(slider.min, slider.max)
                        },
                    );
                    this.kite_ratio = 1;
                },
                debug() {
                    ["num", "theta_deg", "height_ratio", "kite_ratio"].forEach(
                        (key) => console.log(key, this[key])
                    );
                },
                get_slider(key) {
                    return eval(`this.$refs.${key}_slider`);
                },
                clamp(key, value) {
                    const slider = this.get_slider(key);
                    this[key] = this.format(key, _.clamp(value, slider.min, slider.max));
                },
                add_vertice(p) {
                    vertices.push(p);
                    return vertices.length - 1;
                },
                clear() {
                    // Clear data
                    vertices = [];
                    faces = [];
                    iTriangles = [];
                    pieces = [];
                },
                to_suggested_height_ratio(y, WORLD_HEIGHT, polar_height) {
                    return toDecimal((WORLD_HEIGHT - y) / polar_height, FLOAT_PRECISION);
                },
                make_zome() {
                    // Constants
                    const [N, theta_deg, height_ratio, K, is_rhombus] = [
                        this.num,
                        this.theta_deg,
                        this.height_ratio,
                        this.kite_ratio,
                        this.is_rhombus,
                    ]
                    const M = N - 1
                    const cos_theta = Math.cos(deg2rad(theta_deg))
                    const sin_theta = Math.sin(deg2rad(theta_deg))

                    // We calculate the total height of zome, top to top
                    const total_height = WORLD_HEIGHT / height_ratio;
                    const K_sum = is_rhombus ? N : (1 - Math.pow(K, N)) / (1 - K);

                    // Clear all data
                    this.clear();

                    // First Point at the top
                    this.add_vertice([0, WORLD_HEIGHT, 0]);

                    // First ring properties
                    const top_edge = total_height / (K_sum * cos_theta);
                    const ring_radius = top_edge * sin_theta;
                    const ring_height = top_edge * cos_theta;

                    // Add points on first ring every 'TAU / N' from left to right
                    const TAU = Math.PI * 2

                    // Initialize variables
                    let fipr, ficr, k, u, iB, iA, iC, iD, iE, iF, A, B, C, D, E, F, I, dist_to_ground, y;
                    let closest_dist_to_ground = Number.MAX_VALUE;

                    for (let iN = 0; iN < N; iN++) {
                        let a = iN * TAU / N;
                        D = [ring_radius * Math.sin(a), Math.max(0, WORLD_HEIGHT - ring_height), ring_radius * Math.cos(a)];
                        this.add_vertice(D);
                    }

                    // Loop over rings (M = N - 1), while zome does not hit ground
                    let iR = 0, hit_ground = false;
                    for (; iR < M && !hit_ground; iR++) {     // ri => Ring index
                        ficr = iR * N + 1;                      // First Index on current ring
                        fipr = ficr - N;                        // First index on previous ring

                        // On current ring, Loop over points from left to right
                        for (let iN = 0; iN < N; iN++) {
                            k = (iN + 1) % N

                            iA = (iR == 0) ? 0 : fipr + k;      // Index of A point          A
                            iB = ficr + iN;                     // Index of B point        B ◇ C
                            iC = ficr + k;                      // Index of C point          D

                            A = vertices[iA];
                            B = vertices[iB];
                            C = vertices[iC];

                            // Compute the new point to close diamond/kite face
                            D = add(A, mul(sub(mid(B, C), A), 1 + K));

                            // Draw the second part of shape while D is higher than the ground
                            y = toDecimal(D[1], FLOAT_PRECISION);

                            // Add a tolerance to Y
                            if (y + 0.001 >= 0) {
                                // Add Shape to 3D
                                iD = this.add_vertice(D);

                                faces.push(A, B, C);
                                faces.push(B, C, D);

                                // Add shape to pieces
                                if (iN == 0) pieces.push(
                                    (is_rhombus) ? new Rhombus([A, B, D, C]) : new Kite([A, B, D, C])
                                );

                                // Close the zome => Deal with case where this ring is exactly on the ground
                                hit_ground = toDecimal(y, 2) == 0;
                                if (hit_ground) {
                                    iTriangles.push(iD, iD, iC);
                                }
                            } else {
                                // Compute the Truncated Kite
                                u = -B[1] / (D[1] - B[1]);
                                E = add(B, mul(sub(D, B), u));
                                F = add(C, mul(sub(D, C), u));

                                // Add Truncated Kite to 3D
                                iE = this.add_vertice(E);
                                iF = this.add_vertice(F);

                                faces.push(A, B, E)
                                faces.push(A, E, F)
                                faces.push(A, F, C)

                                // Add Truncated Kite to pieces
                                if (iN == 0) pieces.push(new TruncatedKite([A, B, E, F, C]));

                                // Add last triangles to close it after if needed
                                iTriangles.push(iE, iF, iC);
                                hit_ground = true;

                            }
                        }

                        // Compute the suggested height ratio for magnetize button
                        dist_to_ground = Math.abs(y);
                        if (dist_to_ground < closest_dist_to_ground) {
                            closest_dist_to_ground = dist_to_ground;
                            this.suggested_height_ratio = this.to_suggested_height_ratio(y, WORLD_HEIGHT, total_height);
                        }
                    }


                    // Close The Zome
                    let base_vertices = [];
                    const num_triangles = iTriangles.length;
                    if (num_triangles > 0) {
                        for (let iT = 0; iT < num_triangles; iT += 3) {
                            iA = iTriangles[(iT + 2) % num_triangles]
                            iB = iTriangles[(iT + 1) % num_triangles]
                            iC = iTriangles[(iT + 3) % num_triangles]

                            A = vertices[iA];
                            B = vertices[iB];
                            C = vertices[iC];

                            // Don't push base vertices if zome is entire
                            if (this.height_ratio < 1) {
                                base_vertices.push(B);
                            }

                            // Deal with case where B and C are too close, so we don't add them
                            if (toDecimal(dist(B, C), 2) > 0) {
                                // Add triangle to 3D
                                faces.push(A, B, C)

                                // Add triangle to pieces
                                if (iT == 0) pieces.push(new Triangle([A, B, C]));
                            }
                        }
                    }

                    // Finally add the base piece
                    if (base_vertices.length >= 3) {
                        pieces.push(new ZomeBase(base_vertices));
                    }

                    this.$dispatch('zome-is-made', {
                        vertices: vertices,
                        faces: faces,
                        pieces: pieces,
                        num: N,
                    });
                },
            };
        });
    });
</script>
</body>

</html>